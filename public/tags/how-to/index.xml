<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>How-To on Glog</title>
    <link>http://localhost:1313/tags/how-to/</link>
    <description>Recent content in How-To on Glog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 18 Jul 2024 10:43:31 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/how-to/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>跨域</title>
      <link>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 18 Jul 2024 10:43:31 +0000</pubDate>
      <guid>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;跨域是什么&#34;&gt;跨域是什么&lt;/h2&gt;&#xA;&lt;p&gt;跨域只发生在浏览器的访问中，发生跨域时，通常会看到 CORS error 等字眼，并且请求返回了 403 状态码。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;57&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png&#34; alt=&#34;&#34; class=&#34;wp-image-179&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-300x17.png 300w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-768x43.png 768w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2.png 1080w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;为什么会跨域&#34;&gt;为什么会跨域&lt;/h2&gt;&#xA;&lt;p&gt;在理解跨域之前，要先知道浏览器中的同源策略。&lt;/p&gt;&#xA;&lt;p&gt;同源策略：是指两个页面具有相同的协议、地址、端口，那么它们就是同源，只要有一个不同，就不是同源。不同源之间的访问，就会产生跨域。&lt;/p&gt;&#xA;&lt;p&gt;例如 &lt;a href=&#34;https://a.com&#34;&gt;https://a.com&lt;/a&gt; 页面里边的 JavaScript 脚本去访问 &lt;a href=&#34;https://b.com&#34;&gt;https://b.com&lt;/a&gt; ，就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;p&gt;同源策略的目的是为了保护用户隐私和数据安全，但是我们还是有需要进行合法的跨域访问的。比如我们的图片资源都是存在一个独立的 CDN 资源中，其他业务都统一来这个域名访问资源，这之间就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何解决跨域&#34;&gt;如何解决跨域&lt;/h2&gt;&#xA;&lt;p&gt;目前最常见解决跨域的办法，就是通过 CORS(跨域资源共享)。&lt;/p&gt;&#xA;&lt;p&gt;CORS(跨域资源共享)：通过设置HTTP头来允许跨域请求。&lt;/p&gt;&#xA;&lt;p&gt;在上述的例子中，a.com 如何知道自己能够跨域访问 b.com 呢？它会在发起 GET、POST 等这些请求前，先发起一个 preflight 的请求，也就是 OPTIONS 请求，根据返回判断 b.com 是否允许自己访问。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的一点是，并不是所有的跨域都会发起 preflight 请求，同时满足以下情况是不会发起 OPTIONS 请求的：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    请求方法是 GET、POST、HEAD&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    请求中没有特殊的请求头&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;跨域主要涉及的请求头信息：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Origin&amp;nbsp;用于设置允许跨域请求源地址 （预检请求和正式请求在跨域时候都会验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Headers&amp;nbsp;跨域允许携带的特殊头信息字段 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Methods&amp;nbsp;跨域允许的请求方法或者说HTTP动词 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Credentials&amp;nbsp;是否允许跨域使用cookies，如果要跨域使用cookies，可以添加上此请求响应头，值设为true（设置或者不设置，都不会影响请求发送，只会影响在跨域时候是否要携带cookies，但是如果设置，预检请求和正式请求都需要设置）&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安全起见，Access-Control-Allow-Origin 一般不会设置 * 对所有开放，而是指定域名开放&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;nginx中解决跨域&#34;&gt;Nginx中解决跨域&lt;/h3&gt;&#xA;&lt;p&gt;在 Nginx 的配置中，需要处理 OPTIONS 请求，同时对于 OPTIONS 之后的请求也需要添加对应的响应头&lt;/p&gt;</description>
    </item>
    <item>
      <title>dig &#43;trace 输出解读</title>
      <link>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 27 Apr 2024 04:18:43 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</guid>
      <description>&lt;p&gt;这几天遇到了一个 DNS 问题，然后在使用 dig 的过程中，很多字段自己只是一知半解，有点模糊，特意抽时间了解了这方面的内容，顺便记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dns递归解析过程&#34;&gt;DNS递归解析过程&lt;/h3&gt;&#xA;&lt;p&gt;DNS 服务器分类：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    递归 DNS 解析器&lt;br /&gt;类似运营商下发的 DNS 服务器或者像阿里云、腾讯云 dnspod 这种，都是递归 DNS 解析器，其中像阿里云、腾讯云这种对公共开放的 DNS，也称 &lt;strong&gt;公共 DNS&lt;/strong&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    根域名服务器&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    TLD 名称服务器&lt;br /&gt;顶级域名服务器，类似 &lt;strong&gt;.com&lt;/strong&gt; ，&lt;strong&gt;.org &lt;/strong&gt;这种&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    权威性域名服务器&lt;br /&gt;类似 &lt;strong&gt;ns-115.awsdns-14.com.&lt;/strong&gt; ，会给你返回最终的解析结果给到递归 DNS 解析器，递归 DNS 解析器再返回给客户端&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;递归 DNS 的解析过程，引用 cloudflare 的示意图，更详细的过程参考 &lt;a href=&#34;https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/&#34;&gt;cloudflare文档&lt;/a&gt;&lt;figure class=&#34;wp-block-gallery has-nested-images columns-default is-cropped wp-block-gallery-1 is-layout-flex wp-block-gallery-is-layout-flex&#34;&gt; &amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a41e11&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-large wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;512&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; data-id=&#34;123&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png&#34; alt=&#34;&#34; class=&#34;wp-image-123&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-300x150.png 300w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-768x384.png 768w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1536x768.png 1536w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-2048x1024.png 2048w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &lt;/figure&gt; &#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dig-trace&#34;&gt;dig +trace&lt;/h3&gt;&#xA;&lt;p&gt;dig 使用 &lt;code&gt;+trace&lt;/code&gt; 之后，会从根域名服务器开始，一步一步 trace 整个域名的解析过程&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何指定docker compose中容器的网段</title>
      <link>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</link>
      <pubDate>Fri, 19 Apr 2024 01:56:19 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</guid>
      <description>&lt;p&gt;Docker 安装后，看到 &lt;code&gt;docker0&lt;/code&gt; 网卡使用的是 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段，后续 &lt;code&gt;Docker Run&lt;/code&gt; 运行起来不指定网络的容器，拿到的网络地址都是属于这个网段。&lt;/p&gt;&#xA;&lt;p&gt;但是对于利用 Docker Compose 启动得到的容器，它们的 IP 地址并不是从 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段获取的，而是重新创建了一个虚拟网卡，分配了一个新的网给它的容器的使用。&lt;/p&gt;&#xA;&lt;p&gt;默认 Docker Compose 会从 &lt;code&gt;172.16.0.0/12&lt;/code&gt; 网络的地址范围 （&lt;code&gt;172.16.0.0/16&lt;/code&gt; ~ &lt;code&gt;172.31.255.255/16）&lt;/code&gt; 中挑选一个不重复的进行使用。但是有的时候 Docker Compose 挑选到的网络会和我们网络内其他网段冲突，就会导致容器和那个网络段的服务访问会有问题（路由会有问题），这个时候我们就要手动指定网段，解决网络冲突。&lt;/p&gt;&#xA;&lt;p&gt;配置如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-json&#34; data-lang=&#34;JSON&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;&lt;p&gt;services:&#xA;frontend:&#xA;image: frontend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;backend:&#xA;image: backend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;networks:&#xA;custom-network:&#xA;driver: bridge&#xA;ipam:&#xA;config:&#xA;- subnet: 192.168.250.0/24&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>利用SSH Tunnel内网穿透</title>
      <link>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Thu, 28 Mar 2024 06:14:37 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>&lt;p&gt;SSH 除了平时连接远程服务器外，还有不少其他的功能，刚好最近有这个需求，利用了 SSH Tunnel 实现内网穿透，这里简单记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;前提&#34;&gt;前提&lt;/h3&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    需要访问的内网服务器 A&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    有公网地址外网服务器 B&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;利用公网服务器 B 来暴露服务器 A 中的端口，需要 A 主动通过 SSH 连接服务器 B&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;配置过程&#34;&gt;配置过程&lt;/h3&gt;&#xA;&lt;p&gt;SSH 原生支持远程端口转发，在内网服务器 A 上执行以下命令：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 内网服务器 A 上执行&#xA;# ssh -fN -R 23456:127.0.0.1:22 -i xxx.key B_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;命令解释：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    23456 端口，是监听在公网服务器 B 上的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    127.0.0.1:22 表示将内网服务器 A 的 ssh 端口映射到公网服务器 23456 端口&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -f 表示后台运行&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -N 不执行远程命令。端口转发时使用&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个时候在第三台服务器 C 上，就可以通过公网服务器 B 的公网地址 + 23456 端口，访问到内网服务器 A 了&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 三方服务器 C 上执行&#xA;$ ssh -p 23456 A_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;进一步优化&#34;&gt;进一步优化&lt;/h3&gt;&#xA;&lt;p&gt;SSH 的连接有时会因为网络不稳定而断开，我们可以使用 &lt;a href=&#34;https://github.com/Autossh/autossh&#34;&gt;autossh&lt;/a&gt; 这个工具来帮我们维持 SSH 连接，在断开时自动重连。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何只更新Docker Compose中某个容器的版本</title>
      <link>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sat, 23 Mar 2024 15:44:45 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;p&gt;遇到了很多次这个场景，发布版本的时候，只需要更新 Docker Compose 中某个容器的镜像版本并重启，不需要重启其他依赖的容器。&lt;/p&gt;&#xA;&lt;p&gt;其实 Docker 已经为我们考虑到了这个问题了，并提供了相应的参数。&lt;/p&gt;&#xA;&lt;p&gt;方法一：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    更新 &lt;code&gt;docker-compose.yml &lt;/code&gt;中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    重新执行 &lt;code&gt;docker compose up -d &lt;/code&gt;，会自动判断那个 service 发生了变化，并重启变化的容器&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;方法二：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    同样是更新 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    执行 up 时，加上 &lt;code&gt;--no-deps&lt;/code&gt; 的参数，也能做到不重启其他依赖容器。这种做法的好处是可以明确指定那个容器，如果有多个容器需要重启，能做到有顺序的重启&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker compose up -d --no-deps container_name&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何配置Docker使用代理拉镜像</title>
      <link>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 06 Mar 2024 11:33:32 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;编辑 &lt;code&gt;&amp;lt;mark style=&amp;quot;background-color:#d9d9d6&amp;quot; class=&amp;quot;has-inline-color&amp;quot;&amp;gt;/etc/systemd/system/docker.service.d/http-proxy.conf&amp;lt;/mark&amp;gt;&lt;/code&gt; ，目录和文件没有就新建一下，然后配置代理内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;[Service]&#xA;Environment=&#34;HTTP_PROXY=http://xxx.com:80&#34;&#xA;Environment=&#34;HTTPS_PROXY=https://xxx.com:443&#34;&#xA;Environment=&#34;NO_PROXY=xxx-registry.com,*.example.com&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;重启 Docker&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 重启Docker&#xA;sudo systemctl daemon-reload&#xA;sudo systemctl restart docker&#xA;&lt;h1 id=&#34;检查是否正确配置&#34;&gt;检查是否正确配置&lt;/h1&gt;&#xA;&lt;p&gt;sudo systemctl show &amp;ndash;property=Environment docker&lt;/p&gt;&#xA;&lt;h1 id=&#34;确认结果&#34;&gt;确认结果&lt;/h1&gt;&#xA;&lt;p&gt;sudo docker info&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何在容器中添加hosts记录</title>
      <link>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 19 Feb 2024 16:07:56 +0000</pubDate>
      <guid>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;有时候需要在容器中配置指定 hosts ，这里记录一下各个场景的配置方式&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-run&#34;&gt;Docker run&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker run --add-host=xxx.example.com:10.0.0.8 --name debian -it debian&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-compose&#34;&gt;Docker compose&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;services:&#xA;  web:&#xA;    image: nginx&#xA;    extra_hosts:&#xA;      - &#34;docker:10.0.0.10&#34;&#xA;      - &#34;another-host:10.0.0.11&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hostaliases-pod&#xA;spec:&#xA;  restartPolicy: Never&#xA;  hostAliases:&#xA;  - ip: &#34;127.0.0.1&#34;&#xA;    hostnames:&#xA;    - &#34;foo.local&#34;&#xA;    - &#34;bar.local&#34;&#xA;  - ip: &#34;10.1.2.3&#34;&#xA;    hostnames:&#xA;    - &#34;foo.remote&#34;&#xA;    - &#34;bar.remote&#34;&#xA;  containers:&#xA;  - name: cat-hosts&#xA;    image: busybox:1.28&#xA;    command:&#xA;    - cat&#xA;    args:&#xA;    - &#34;/etc/hosts&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
