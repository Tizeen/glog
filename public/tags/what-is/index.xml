<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>What-Is on Glog</title>
    <link>http://localhost:1313/tags/what-is/</link>
    <description>Recent content in What-Is on Glog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 07 Nov 2024 15:55:28 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/what-is/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tracepath Traceroute MTR</title>
      <link>http://localhost:1313/2024/11/07/tracepath-traceroute-mtr/</link>
      <pubDate>Thu, 07 Nov 2024 15:55:28 +0000</pubDate>
      <guid>http://localhost:1313/2024/11/07/tracepath-traceroute-mtr/</guid>
      <description>&lt;p&gt;最近工作配合排查了好几次网络问题，于是经常用到了 tracepath、traceroute 和 mtr，三个工具都是跟踪并查找网络线路的，但是又各有差异，这里简单记录一下。&lt;/p&gt;&#xA;&lt;p&gt;tracepath 利用 &lt;strong&gt;UDP&lt;/strong&gt; 协议，通过回来的数据包探测网络线路，并且在执行时不需要 root 权限，在权限不够的情况下，使用 tracepath 是一个很好的选择。&lt;/p&gt;&#xA;&lt;p&gt;traceroute 则是利用 ICMP 协议来探测网络线路，同时可以通过参数指定使用 TCP、UDP协议来探测，可以看下述例子。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;614&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-1024x614.jpg&#34; alt=&#34;&#34; class=&#34;wp-image-275&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-1024x614.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-300x180.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-768x460.jpg 768w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034.jpg 1452w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;解读：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    * * * 表示没有返回数据包，这在一些商业设备中很常见，它们屏蔽了来自 traceroute 的探测&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    ip 后边的 ms 则是源到这个点的 RTT，每次 traceroute 会发送 3 个数据包来验证&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;mtr 是 My Traceroute 缩写，它是 traceroute 和 ping 的结合体，除了能看到网络经过的各个点，它还可以显示到目的地的路线中不断更新的延迟和丢包信息，可以实时看到路径上发生的情况，协助排除网络问题。&lt;figure class=&#34;wp-block-gallery has-nested-images columns-default is-cropped wp-block-gallery-5 is-layout-flex wp-block-gallery-is-layout-flex&#34;&gt; &amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a4a7dd&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-full is-style-default wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;2560&#34; height=&#34;716&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; data-id=&#34;279&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-scaled.jpg&#34; alt=&#34;&#34; class=&#34;wp-image-279&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-scaled.jpg 2560w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-300x84.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-1024x287.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-768x215.jpg 768w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-1536x430.jpg 1536w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-2048x573.jpg 2048w&#34; sizes=&#34;auto, (max-width: 2560px) 100vw, 2560px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &lt;/figure&gt; &#xA;&lt;p&gt;解读：&lt;/p&gt;</description>
    </item>
    <item>
      <title>重新认识Kubernetes events</title>
      <link>http://localhost:1313/2024/08/27/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86kubernetes-events/</link>
      <pubDate>Tue, 27 Aug 2024 02:56:54 +0000</pubDate>
      <guid>http://localhost:1313/2024/08/27/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86kubernetes-events/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;event是什么&#34;&gt;event是什么&lt;/h2&gt;&#xA;&lt;p&gt;Kubernetes 中的组件状态发生变化，它就会产生一个事件，也就是 event 。在 event 中提供了集群的状态和健康信息，例如：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    容器创建失败&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Pod 在不停的被调度&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;事件存储在 Etcd 中，&lt;strong&gt;默认只存储最近 1 个小时&lt;/strong&gt;。如果需要持久化事件，可以通过 &lt;a href=&#34;https://github.com/resmoio/kubernetes-event-exporter&#34;&gt;kubernetes-event-exporter&lt;/a&gt; 持久化到 ElasticSearch 中。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;event的数据结构&#34;&gt;event的数据结构&lt;/h2&gt;&#xA;&lt;p&gt;平时使用比较多的查看 event 的方法&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl describe node &amp;lt;node_name&amp;gt;&#xA;&lt;p&gt;kubectl describe pod &amp;lt;pod_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;204&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1024x204.png&#34; alt=&#34;&#34; class=&#34;wp-image-226&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1024x204.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-300x60.png 300w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-768x153.png 768w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1536x306.png 1536w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-2048x408.png 2048w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里显示了常用的字段，如果需要查看完整的字段，可以&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl get events -ojson&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;925&#34; height=&#34;1024&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-925x1024.png&#34; alt=&#34;&#34; class=&#34;wp-image-228&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-925x1024.png 925w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-271x300.png 271w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-768x850.png 768w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2.png 1234w&#34; sizes=&#34;auto, (max-width: 925px) 100vw, 925px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP缓存</title>
      <link>http://localhost:1313/2024/08/05/http%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 05 Aug 2024 03:30:41 +0000</pubDate>
      <guid>http://localhost:1313/2024/08/05/http%E7%BC%93%E5%AD%98/</guid>
      <description>&lt;p&gt;最近一直在搞 CDN 相关的东西，碰到最多的便是缓存了，简单记录一下相应的内容。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;缓存是什么&#34;&gt;缓存是什么&lt;/h2&gt;&#xA;&lt;p&gt;客户端浏览器访问网页时，需要从服务端拉取到相应的资源，但是有的客户端离服务端可能会很远，访问的时候会直观感受到 &lt;strong&gt;慢&lt;/strong&gt;，缓存就是用来解决这一问题的。&lt;/p&gt;&#xA;&lt;p&gt;缓存有哪些：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    本地缓存。浏览器会根据请求头的策略，将数据缓存在内存或者磁盘中&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;550&#34; height=&#34;208&#34; class=&#34;wp-image-197&#34; style=&#34;width: 550px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33.jpg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33.jpg 1482w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-300x114.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-1024x388.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-768x291.jpg 768w&#34; sizes=&#34;auto, (max-width: 550px) 100vw, 550px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    CDN。Content Delivery Network，将资源先存放在离用户近的地方，这样用户访问的链路更短，访问的时候便可以加速，同时 CDN 访问服务端源站也会有相应的加成（CDN提供商的网络比客户本地的网络会更可靠）&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何控制缓存&#34;&gt;如何控制缓存&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;浏览器如何确定我能否缓存这个资源呢?&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;它是通过 http Response 中的 &lt;strong&gt;Cache-Control&lt;/strong&gt; 请求头来决定的。&lt;/p&gt;&#xA;&lt;p&gt;缓存行为：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    public ：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    private ：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    no-cache ：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    no-store ：不使用任何缓存&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存时间：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    max-age=&lt;seconds&gt; &lt;br /&gt;设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)，时间是相对于请求的时间。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;目前接触比较多的参数主要是上述这些，更多的参数可以参照 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control&#34;&gt;MDN文档&lt;/a&gt;。除了&lt;br&gt;&#xA;Cache-Control 头之外，http 中还会通过 Etag 请求头作为资源的唯一标签。&lt;/p&gt;&#xA;&lt;p&gt;在缓存到期之后，再请求资源，客户端会通过 If-None-Match 带上 Etag 的内容，发送给服务端，服务端判断资源是否发生变化，未发生变化，则返回 304 Not Modified，这样就无需再传输完整的资源，节省了带宽。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;浏览器如何判断缓存过期了呢？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;服务端响应的头中，除了 Cache-Control ，还有一个 Date 的头，记录请求的时间，这样便可以根据 Date + max-age 的秒数，拿到缓存的到期时间，再次请求资源时，缓存有效则直接使用缓存的资源。&lt;/p&gt;</description>
    </item>
    <item>
      <title>跨域</title>
      <link>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 18 Jul 2024 10:43:31 +0000</pubDate>
      <guid>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;跨域是什么&#34;&gt;跨域是什么&lt;/h2&gt;&#xA;&lt;p&gt;跨域只发生在浏览器的访问中，发生跨域时，通常会看到 CORS error 等字眼，并且请求返回了 403 状态码。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;57&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png&#34; alt=&#34;&#34; class=&#34;wp-image-179&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-300x17.png 300w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-768x43.png 768w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2.png 1080w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;为什么会跨域&#34;&gt;为什么会跨域&lt;/h2&gt;&#xA;&lt;p&gt;在理解跨域之前，要先知道浏览器中的同源策略。&lt;/p&gt;&#xA;&lt;p&gt;同源策略：是指两个页面具有相同的协议、地址、端口，那么它们就是同源，只要有一个不同，就不是同源。不同源之间的访问，就会产生跨域。&lt;/p&gt;&#xA;&lt;p&gt;例如 &lt;a href=&#34;https://a.com&#34;&gt;https://a.com&lt;/a&gt; 页面里边的 JavaScript 脚本去访问 &lt;a href=&#34;https://b.com&#34;&gt;https://b.com&lt;/a&gt; ，就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;p&gt;同源策略的目的是为了保护用户隐私和数据安全，但是我们还是有需要进行合法的跨域访问的。比如我们的图片资源都是存在一个独立的 CDN 资源中，其他业务都统一来这个域名访问资源，这之间就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何解决跨域&#34;&gt;如何解决跨域&lt;/h2&gt;&#xA;&lt;p&gt;目前最常见解决跨域的办法，就是通过 CORS(跨域资源共享)。&lt;/p&gt;&#xA;&lt;p&gt;CORS(跨域资源共享)：通过设置HTTP头来允许跨域请求。&lt;/p&gt;&#xA;&lt;p&gt;在上述的例子中，a.com 如何知道自己能够跨域访问 b.com 呢？它会在发起 GET、POST 等这些请求前，先发起一个 preflight 的请求，也就是 OPTIONS 请求，根据返回判断 b.com 是否允许自己访问。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的一点是，并不是所有的跨域都会发起 preflight 请求，同时满足以下情况是不会发起 OPTIONS 请求的：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    请求方法是 GET、POST、HEAD&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    请求中没有特殊的请求头&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;跨域主要涉及的请求头信息：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Origin&amp;nbsp;用于设置允许跨域请求源地址 （预检请求和正式请求在跨域时候都会验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Headers&amp;nbsp;跨域允许携带的特殊头信息字段 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Methods&amp;nbsp;跨域允许的请求方法或者说HTTP动词 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Credentials&amp;nbsp;是否允许跨域使用cookies，如果要跨域使用cookies，可以添加上此请求响应头，值设为true（设置或者不设置，都不会影响请求发送，只会影响在跨域时候是否要携带cookies，但是如果设置，预检请求和正式请求都需要设置）&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安全起见，Access-Control-Allow-Origin 一般不会设置 * 对所有开放，而是指定域名开放&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;nginx中解决跨域&#34;&gt;Nginx中解决跨域&lt;/h3&gt;&#xA;&lt;p&gt;在 Nginx 的配置中，需要处理 OPTIONS 请求，同时对于 OPTIONS 之后的请求也需要添加对应的响应头&lt;/p&gt;</description>
    </item>
    <item>
      <title>SNI</title>
      <link>http://localhost:1313/2024/04/02/sni/</link>
      <pubDate>Tue, 02 Apr 2024 02:56:32 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/02/sni/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;sni是什么&#34;&gt;SNI是什么&lt;/h3&gt;&#xA;&lt;p&gt;SNI: Server Name Indication 服务名称标识。顾名思义，是用来标识服务名的&lt;/p&gt;&#xA;&lt;p&gt;服务名：一般表示的是网站域名&lt;/p&gt;&#xA;&lt;p&gt;在现如今的 Web 服务器，一般同个 IP + 端口 会包含多个网站，在 https 协议中，每个域名可能都会有自己的证书，如果只有 IP 地址，在访问 https 的时候，服务端不足以判断访问哪个域名，从而可能导致 &lt;strong&gt;SSL证书错误&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;SNI 就是用来标识访问的域名是哪个，起到一个引路的作用。&lt;/p&gt;&#xA;&lt;p&gt;SNI 主要用在 https 中，在 http 中是没有 SNI 的，因为 http 没有 tls 握手的过程，直接通过请求头中的 Host 字段判断访问的哪个域名。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;sni的体现&#34;&gt;SNI的体现&lt;/h3&gt;&#xA;&lt;p&gt;SNI 主要在 TLS 握手的 client hello 的扩展信息中，以此发给服务端&amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a3f7fb&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-large wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;604&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/image-1024x604.png&#34; alt=&#34;&#34; class=&#34;wp-image-93&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/image-1024x604.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/04/image-300x177.png 300w, https://glog.likungong.com/wp-content/uploads/2024/04/image-768x453.png 768w, https://glog.likungong.com/wp-content/uploads/2024/04/image.png 1230w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &#xA;&lt;p&gt;在 Nginx 中配置多 https 的例子：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S Pod QoS</title>
      <link>http://localhost:1313/2024/03/20/k8s-pod-qos/</link>
      <pubDate>Wed, 20 Mar 2024 14:51:00 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/20/k8s-pod-qos/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;pod-qos是什么&#34;&gt;Pod QoS是什么&lt;/h3&gt;&#xA;&lt;p&gt;QoS：Quality of Service，服务质量的意思。K8S Pod QoS 主要是对 Pod 的资源进行管理和限制的一种机制。&lt;/p&gt;&#xA;&lt;p&gt;QoS类型：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Guaranteed：最高优先级&lt;br /&gt;Pod 中每个容器的内存和 CPU 的 request 和 limit 是一致的，不同容器的配置值是可以不相等&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Burstable：可以短期使用更多的资源&lt;br /&gt;&amp;#8211; 设置了内存和 CPU 的 request，但是没有配置 limit&lt;br /&gt;&amp;#8211; 或者设置了 request 和 limit，但是两者不相等&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    BestEffort：最低优先级&lt;br /&gt;没有设置任何 request 和 limit&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果 Pod 中只配置了 limit，没有配置 request，那么 K8S 会复制 limit 的值提供给 requests 。&lt;/p&gt;&#xA;&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;&#xA;  &lt;p&gt;&#xA;    Note:&#xA;  &lt;/p&gt;&#xA;&lt;p&gt;&lt;cite&gt;If you specify a limit for a resource, but do not specify any request, and no admission-time mechanism has applied a default request for that resource, then Kubernetes copies the limit you specified and uses it as the requested value for the resource.&lt;/cite&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S CPU Throttling</title>
      <link>http://localhost:1313/2024/03/10/k8s-cpu-throttling/</link>
      <pubDate>Sun, 10 Mar 2024 03:26:38 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/10/k8s-cpu-throttling/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;什么是cpu-throttling&#34;&gt;什么是CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;在 K8S 中，内存有很明确的大小指标来衡量，一旦超过设定的 Limit，就会发生 OOM ，被系统 Kill 掉，这就是 PodOOM 事件。&lt;br&gt;&#xA;而 CPU 的衡量指标则有点模糊，是根据占据 CPU 的使用时间来决定的。CPU 使用超限了 Pod 也不会被杀掉，而是 CPU 使用会被限流。&lt;/p&gt;&#xA;&lt;p&gt;CPU Throttling 直译来说就是 CPU 使用被节流了，被限制了 CPU 的使用时间。&lt;/p&gt;&#xA;&lt;p&gt;在 K8S 中，通过调整容器中进程的 CPU 优先级(nice值，值越小，优先级越高)来达到限流的效果。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;cpu-throttling影响什么&#34;&gt;CPU Throttling影响什么&lt;/h3&gt;&#xA;&lt;p&gt;影响：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    CPU 处理变慢了，导致服务性能下降，response_time 响应时间增加&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;如何监控cpu-throttling&#34;&gt;如何监控CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;cadvisor 提供了相应指标：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    container_cpu_cfs_throttled_periods_total&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    container_cpu_cfs_periods_total&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;一个 PromQL例子&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-sql&#34; data-lang=&#34;SQL&#34;&gt;&lt;code&gt;sum(increase(container_cpu_cfs_throttled_periods_total{container!=&#34;filebeat&#34;,cluster!~&#34;kube.*-(dev|test|pre|t|t2|t3|s|u|d)$&#34;}[5m])) by (container, pod, namespace, cluster)&#xA;  /&#xA;sum(increase(container_cpu_cfs_periods_total{cluster!~&#34;kube.*-(dev|test|pre|t|t2|t3|s|u|d)$&#34;}[5m])) by (container, pod, namespace, cluster)&#xA;  &amp;gt; ( 10 / 100 )&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;如何解决cpu-throttling&#34;&gt;如何解决CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;解决：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker compose中expose和port的区别</title>
      <link>http://localhost:1313/2024/02/21/docker-compose-expose%E5%92%8Cport%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 21 Feb 2024 15:48:19 +0000</pubDate>
      <guid>http://localhost:1313/2024/02/21/docker-compose-expose%E5%92%8Cport%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    expose 指定的端口，是提供给 compose 中其他 service 用的，不会映射到宿主机上。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    port 指定的端口，则会映射到宿主机上。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;expose&#34;&gt;expose&lt;/h4&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;services:&#xA;  myapp1:&#xA;    .&#xA;    expose:&#xA;      - &#34;3000&#34;&#xA;      - &#34;8000&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;port&#34;&gt;port&lt;/h4&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;services:&#xA;  myapp1:&#xA;    ...&#xA;    ports:&#xA;    - &#34;3000&#34;                 # 容器中的3000端口映射到主机一个随机端口&#xA;    - &#34;3001-3005&#34;            # 容器中的3001-3005端口映射到主机一个随机端口段&#xA;    - &#34;8000:8000&#34;            # 容器中的8000端口映射到主机的8000端口&#xA;    - &#34;9090-9091:8080-8081&#34;  # 容器中的8080-8081映射到主机的9090-9091&#xA;    - &#34;127.0.0.1:8002:8002&#34;  # 容器中的8002端口映射主机127.0.0.1地址的8002&#xA;    - &#34;6060:6060/udp&#34;        # 限制容器中6060端口的udp协议到主机的6060端口  &lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
