<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>How-To on Glog</title>
    <link>http://localhost:1313/categories/how-to/</link>
    <description>Recent content in How-To on Glog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 12 Oct 2024 10:55:36 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/how-to/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K8S中的服务使用GPU</title>
      <link>http://localhost:1313/2024/10/12/k8s%E4%B8%AD%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8gpu/</link>
      <pubDate>Sat, 12 Oct 2024 10:55:36 +0000</pubDate>
      <guid>http://localhost:1313/2024/10/12/k8s%E4%B8%AD%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8gpu/</guid>
      <description>&lt;p&gt;GPU 作为目前图形处理和 AI 任务必须的资源，这里简单记录一下在 K8S 中的程序，它们是如何使用 GPU 的。&lt;/p&gt;&#xA;&lt;p&gt;这里以 AWS EKS 进行相关记录&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li class=&#34;has-medium-font-size&#34;&gt;&#xA;    确保使用的机器是有 GPU 硬件，例如 AWS 的 g4dn，g6 等机型就是带有 GPU 硬件的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    在 EKS 中添加 GPU Node Group，注意使用的 AMI （操作系统镜像）需要带有 GPU 驱动和 cuda，选择 Amazon Linux 2023 Nvidia 的镜像&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    安装 &lt;a href=&#34;https://github.com/NVIDIA/k8s-device-plugin&#34;&gt;&lt;strong&gt;k8s-device-plugin&lt;/strong&gt;&lt;/a&gt; 组件，它会以 daemonset 的方式运行在节点上，如果我们的 GPU 节点配置了对应的污点，安装时需要修改对应的容忍机制&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    安装完 k8s-device-plugin 之后，我们通过 &lt;code&gt;kubectl describe node&lt;/code&gt;，可以在 Capacity 中可以看到可用的 GPU 数量。当我们登录 GPU 节点，执行 &lt;code&gt;nvidia-smi&lt;/code&gt; ，也可以看到 GPU 的相关信息&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;350&#34; height=&#34;125&#34; class=&#34;wp-image-255&#34; style=&#34;width: 350px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352.jpeg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352.jpeg 848w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352-300x107.jpeg 300w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352-768x274.jpeg 768w&#34; sizes=&#34;auto, (max-width: 350px) 100vw, 350px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    使用 GPU 感知的镜像来启动 Pod，例如 &lt;code&gt;nvidia/cuda:11.0-base&lt;/code&gt;，它们内部已经包含了使用 GPU 需要的库、驱动程序、工具，使得容器内的应用程序能够有效地利用GPU资源进行计算&lt;br /&gt;在 deployment 中，我们需要在 requests 中标明需要的 GPU&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;350&#34; height=&#34;103&#34; class=&#34;wp-image-256&#34; style=&#34;width: 350px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532.jpeg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532.jpeg 786w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532-300x89.jpeg 300w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532-768x227.jpeg 768w&#34; sizes=&#34;auto, (max-width: 350px) 100vw, 350px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;至此，我们就可以在 k8s 的容器中调用节点的 GPU 资源了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>跨域</title>
      <link>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 18 Jul 2024 10:43:31 +0000</pubDate>
      <guid>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;跨域是什么&#34;&gt;跨域是什么&lt;/h2&gt;&#xA;&lt;p&gt;跨域只发生在浏览器的访问中，发生跨域时，通常会看到 CORS error 等字眼，并且请求返回了 403 状态码。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;57&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png&#34; alt=&#34;&#34; class=&#34;wp-image-179&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-300x17.png 300w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-768x43.png 768w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2.png 1080w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;为什么会跨域&#34;&gt;为什么会跨域&lt;/h2&gt;&#xA;&lt;p&gt;在理解跨域之前，要先知道浏览器中的同源策略。&lt;/p&gt;&#xA;&lt;p&gt;同源策略：是指两个页面具有相同的协议、地址、端口，那么它们就是同源，只要有一个不同，就不是同源。不同源之间的访问，就会产生跨域。&lt;/p&gt;&#xA;&lt;p&gt;例如 &lt;a href=&#34;https://a.com&#34;&gt;https://a.com&lt;/a&gt; 页面里边的 JavaScript 脚本去访问 &lt;a href=&#34;https://b.com&#34;&gt;https://b.com&lt;/a&gt; ，就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;p&gt;同源策略的目的是为了保护用户隐私和数据安全，但是我们还是有需要进行合法的跨域访问的。比如我们的图片资源都是存在一个独立的 CDN 资源中，其他业务都统一来这个域名访问资源，这之间就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何解决跨域&#34;&gt;如何解决跨域&lt;/h2&gt;&#xA;&lt;p&gt;目前最常见解决跨域的办法，就是通过 CORS(跨域资源共享)。&lt;/p&gt;&#xA;&lt;p&gt;CORS(跨域资源共享)：通过设置HTTP头来允许跨域请求。&lt;/p&gt;&#xA;&lt;p&gt;在上述的例子中，a.com 如何知道自己能够跨域访问 b.com 呢？它会在发起 GET、POST 等这些请求前，先发起一个 preflight 的请求，也就是 OPTIONS 请求，根据返回判断 b.com 是否允许自己访问。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的一点是，并不是所有的跨域都会发起 preflight 请求，同时满足以下情况是不会发起 OPTIONS 请求的：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    请求方法是 GET、POST、HEAD&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    请求中没有特殊的请求头&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;跨域主要涉及的请求头信息：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Origin&amp;nbsp;用于设置允许跨域请求源地址 （预检请求和正式请求在跨域时候都会验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Headers&amp;nbsp;跨域允许携带的特殊头信息字段 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Methods&amp;nbsp;跨域允许的请求方法或者说HTTP动词 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Credentials&amp;nbsp;是否允许跨域使用cookies，如果要跨域使用cookies，可以添加上此请求响应头，值设为true（设置或者不设置，都不会影响请求发送，只会影响在跨域时候是否要携带cookies，但是如果设置，预检请求和正式请求都需要设置）&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安全起见，Access-Control-Allow-Origin 一般不会设置 * 对所有开放，而是指定域名开放&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;nginx中解决跨域&#34;&gt;Nginx中解决跨域&lt;/h3&gt;&#xA;&lt;p&gt;在 Nginx 的配置中，需要处理 OPTIONS 请求，同时对于 OPTIONS 之后的请求也需要添加对应的响应头&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S ServiceAccount</title>
      <link>http://localhost:1313/2024/05/31/k8s-serviceaccount/</link>
      <pubDate>Fri, 31 May 2024 15:39:46 +0000</pubDate>
      <guid>http://localhost:1313/2024/05/31/k8s-serviceaccount/</guid>
      <description>&lt;p&gt;近期又频繁接触 K8S，发现以前自己学的很多都已经发生变化，觉得有必要记录一下。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;serviceaccount是什么&#34;&gt;ServiceAccount是什么&lt;/h2&gt;&#xA;&lt;p&gt;服务账号，顾名思义是用来做身份标识的，它与平时接触的账号又有一些不一样。在 K8S 中，Pod、系统组件以及集群外的实体都可以使用 &lt;strong&gt;ServiceAccount 凭证&lt;/strong&gt; 标识自己为对应的 ServiceAccount，以此来获取访问 K8S 其他资源的权限。&lt;/p&gt;&#xA;&lt;p&gt;可以通过以下命令查看 ServiceAccount&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl get sa -n default&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;serviceaccount使用场景&#34;&gt;ServiceAccount使用场景&lt;/h2&gt;&#xA;&lt;p&gt;目前接触到的使用场景有这些：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    利用 ServiceAccount 的 secret，生成一个 kubeconfig 作为 CD 流水线中操作 K8S 的凭证&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    在 Pod 中利用 ServiceAccount 和 K8S 自身通信，调用 API 启动 JOB 类型的 Pod，或者拿到 configmap 中的配置&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    将 AWS 的 role 绑定到对应的 ServiceAccount，使 Pod 拥有对应 role 的权限，比如直接访问 S3 的权限&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;使用serviceaccount-token生成kubeconfig&#34;&gt;使用ServiceAccount token生成kubeconfig&lt;/h3&gt;&#xA;&lt;p&gt;通过以下方法创建一个长期有效的 Token（&lt;strong&gt;长期有效的 token 可能造成安全问题&lt;/strong&gt;，谨慎使用），主要是&lt;br&gt;&#xA;&lt;code&gt;type: kubernetes.io/service-account-token&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF&#xA;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: sa-secret&#xA;  annotations:&#xA;    kubernetes.io/service-account.name: sa&#xA;type: kubernetes.io/service-account-token&#xA;EOF&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;查看 token&lt;/p&gt;</description>
    </item>
    <item>
      <title>dig &#43;trace 输出解读</title>
      <link>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 27 Apr 2024 04:18:43 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</guid>
      <description>&lt;p&gt;这几天遇到了一个 DNS 问题，然后在使用 dig 的过程中，很多字段自己只是一知半解，有点模糊，特意抽时间了解了这方面的内容，顺便记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dns递归解析过程&#34;&gt;DNS递归解析过程&lt;/h3&gt;&#xA;&lt;p&gt;DNS 服务器分类：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    递归 DNS 解析器&lt;br /&gt;类似运营商下发的 DNS 服务器或者像阿里云、腾讯云 dnspod 这种，都是递归 DNS 解析器，其中像阿里云、腾讯云这种对公共开放的 DNS，也称 &lt;strong&gt;公共 DNS&lt;/strong&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    根域名服务器&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    TLD 名称服务器&lt;br /&gt;顶级域名服务器，类似 &lt;strong&gt;.com&lt;/strong&gt; ，&lt;strong&gt;.org &lt;/strong&gt;这种&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    权威性域名服务器&lt;br /&gt;类似 &lt;strong&gt;ns-115.awsdns-14.com.&lt;/strong&gt; ，会给你返回最终的解析结果给到递归 DNS 解析器，递归 DNS 解析器再返回给客户端&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;递归 DNS 的解析过程，引用 cloudflare 的示意图，更详细的过程参考 &lt;a href=&#34;https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/&#34;&gt;cloudflare文档&lt;/a&gt;&lt;figure class=&#34;wp-block-gallery has-nested-images columns-default is-cropped wp-block-gallery-1 is-layout-flex wp-block-gallery-is-layout-flex&#34;&gt; &amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a41e11&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-large wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;512&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; data-id=&#34;123&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png&#34; alt=&#34;&#34; class=&#34;wp-image-123&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-300x150.png 300w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-768x384.png 768w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1536x768.png 1536w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-2048x1024.png 2048w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &lt;/figure&gt; &#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dig-trace&#34;&gt;dig +trace&lt;/h3&gt;&#xA;&lt;p&gt;dig 使用 &lt;code&gt;+trace&lt;/code&gt; 之后，会从根域名服务器开始，一步一步 trace 整个域名的解析过程&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何指定docker compose中容器的网段</title>
      <link>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</link>
      <pubDate>Fri, 19 Apr 2024 01:56:19 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</guid>
      <description>&lt;p&gt;Docker 安装后，看到 &lt;code&gt;docker0&lt;/code&gt; 网卡使用的是 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段，后续 &lt;code&gt;Docker Run&lt;/code&gt; 运行起来不指定网络的容器，拿到的网络地址都是属于这个网段。&lt;/p&gt;&#xA;&lt;p&gt;但是对于利用 Docker Compose 启动得到的容器，它们的 IP 地址并不是从 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段获取的，而是重新创建了一个虚拟网卡，分配了一个新的网给它的容器的使用。&lt;/p&gt;&#xA;&lt;p&gt;默认 Docker Compose 会从 &lt;code&gt;172.16.0.0/12&lt;/code&gt; 网络的地址范围 （&lt;code&gt;172.16.0.0/16&lt;/code&gt; ~ &lt;code&gt;172.31.255.255/16）&lt;/code&gt; 中挑选一个不重复的进行使用。但是有的时候 Docker Compose 挑选到的网络会和我们网络内其他网段冲突，就会导致容器和那个网络段的服务访问会有问题（路由会有问题），这个时候我们就要手动指定网段，解决网络冲突。&lt;/p&gt;&#xA;&lt;p&gt;配置如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-json&#34; data-lang=&#34;JSON&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;&lt;p&gt;services:&#xA;frontend:&#xA;image: frontend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;backend:&#xA;image: backend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;networks:&#xA;custom-network:&#xA;driver: bridge&#xA;ipam:&#xA;config:&#xA;- subnet: 192.168.250.0/24&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>利用SSH Tunnel内网穿透</title>
      <link>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Thu, 28 Mar 2024 06:14:37 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>&lt;p&gt;SSH 除了平时连接远程服务器外，还有不少其他的功能，刚好最近有这个需求，利用了 SSH Tunnel 实现内网穿透，这里简单记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;前提&#34;&gt;前提&lt;/h3&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    需要访问的内网服务器 A&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    有公网地址外网服务器 B&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;利用公网服务器 B 来暴露服务器 A 中的端口，需要 A 主动通过 SSH 连接服务器 B&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;配置过程&#34;&gt;配置过程&lt;/h3&gt;&#xA;&lt;p&gt;SSH 原生支持远程端口转发，在内网服务器 A 上执行以下命令：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 内网服务器 A 上执行&#xA;# ssh -fN -R 23456:127.0.0.1:22 -i xxx.key B_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;命令解释：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    23456 端口，是监听在公网服务器 B 上的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    127.0.0.1:22 表示将内网服务器 A 的 ssh 端口映射到公网服务器 23456 端口&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -f 表示后台运行&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -N 不执行远程命令。端口转发时使用&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个时候在第三台服务器 C 上，就可以通过公网服务器 B 的公网地址 + 23456 端口，访问到内网服务器 A 了&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 三方服务器 C 上执行&#xA;$ ssh -p 23456 A_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;进一步优化&#34;&gt;进一步优化&lt;/h3&gt;&#xA;&lt;p&gt;SSH 的连接有时会因为网络不稳定而断开，我们可以使用 &lt;a href=&#34;https://github.com/Autossh/autossh&#34;&gt;autossh&lt;/a&gt; 这个工具来帮我们维持 SSH 连接，在断开时自动重连。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何只更新Docker Compose中某个容器的版本</title>
      <link>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sat, 23 Mar 2024 15:44:45 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;p&gt;遇到了很多次这个场景，发布版本的时候，只需要更新 Docker Compose 中某个容器的镜像版本并重启，不需要重启其他依赖的容器。&lt;/p&gt;&#xA;&lt;p&gt;其实 Docker 已经为我们考虑到了这个问题了，并提供了相应的参数。&lt;/p&gt;&#xA;&lt;p&gt;方法一：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    更新 &lt;code&gt;docker-compose.yml &lt;/code&gt;中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    重新执行 &lt;code&gt;docker compose up -d &lt;/code&gt;，会自动判断那个 service 发生了变化，并重启变化的容器&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;方法二：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    同样是更新 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    执行 up 时，加上 &lt;code&gt;--no-deps&lt;/code&gt; 的参数，也能做到不重启其他依赖容器。这种做法的好处是可以明确指定那个容器，如果有多个容器需要重启，能做到有顺序的重启&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker compose up -d --no-deps container_name&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何配置Docker使用代理拉镜像</title>
      <link>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 06 Mar 2024 11:33:32 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;编辑 &lt;code&gt;&amp;lt;mark style=&amp;quot;background-color:#d9d9d6&amp;quot; class=&amp;quot;has-inline-color&amp;quot;&amp;gt;/etc/systemd/system/docker.service.d/http-proxy.conf&amp;lt;/mark&amp;gt;&lt;/code&gt; ，目录和文件没有就新建一下，然后配置代理内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;[Service]&#xA;Environment=&#34;HTTP_PROXY=http://xxx.com:80&#34;&#xA;Environment=&#34;HTTPS_PROXY=https://xxx.com:443&#34;&#xA;Environment=&#34;NO_PROXY=xxx-registry.com,*.example.com&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;重启 Docker&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 重启Docker&#xA;sudo systemctl daemon-reload&#xA;sudo systemctl restart docker&#xA;&lt;h1 id=&#34;检查是否正确配置&#34;&gt;检查是否正确配置&lt;/h1&gt;&#xA;&lt;p&gt;sudo systemctl show &amp;ndash;property=Environment docker&lt;/p&gt;&#xA;&lt;h1 id=&#34;确认结果&#34;&gt;确认结果&lt;/h1&gt;&#xA;&lt;p&gt;sudo docker info&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何在容器中添加hosts记录</title>
      <link>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 19 Feb 2024 16:07:56 +0000</pubDate>
      <guid>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;有时候需要在容器中配置指定 hosts ，这里记录一下各个场景的配置方式&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-run&#34;&gt;Docker run&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker run --add-host=xxx.example.com:10.0.0.8 --name debian -it debian&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-compose&#34;&gt;Docker compose&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;services:&#xA;  web:&#xA;    image: nginx&#xA;    extra_hosts:&#xA;      - &#34;docker:10.0.0.10&#34;&#xA;      - &#34;another-host:10.0.0.11&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hostaliases-pod&#xA;spec:&#xA;  restartPolicy: Never&#xA;  hostAliases:&#xA;  - ip: &#34;127.0.0.1&#34;&#xA;    hostnames:&#xA;    - &#34;foo.local&#34;&#xA;    - &#34;bar.local&#34;&#xA;  - ip: &#34;10.1.2.3&#34;&#xA;    hostnames:&#xA;    - &#34;foo.remote&#34;&#xA;    - &#34;bar.remote&#34;&#xA;  containers:&#xA;  - name: cat-hosts&#xA;    image: busybox:1.28&#xA;    command:&#xA;    - cat&#xA;    args:&#xA;    - &#34;/etc/hosts&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
