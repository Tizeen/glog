<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Glog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Glog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 25 May 2025 04:40:56 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>白日梦想家</title>
      <link>http://localhost:1313/2025/05/25/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/</link>
      <pubDate>Sun, 25 May 2025 04:40:56 +0000</pubDate>
      <guid>http://localhost:1313/2025/05/25/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/</guid>
      <description>&lt;p&gt;What is Life？&lt;/p&gt;&#xA;&lt;p&gt;Just find yourself and be yourself.&lt;/p&gt;&#xA;&lt;p&gt;Just try it and enjoy.&lt;/p&gt;</description>
    </item>
    <item>
      <title>20250323</title>
      <link>http://localhost:1313/2025/03/24/20250323/</link>
      <pubDate>Mon, 24 Mar 2025 14:26:00 +0000</pubDate>
      <guid>http://localhost:1313/2025/03/24/20250323/</guid>
      <description>&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    S3 的生命周期规则，不是说删除后就立刻停止，对于已经应用了规则的对象，即使中途将规则删除了，那么这些对象依旧会运行删除的规则&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    断点续传的时间可以是 1 天、1 周，甚至更长，对于云存储的业务，特别要注意这点，不然可能会出问题。&lt;br /&gt;提前删除未上传完成的对象分片，导致断点续传失效，然后客户端也没有做失败后从头开始上传的逻辑，最终导致线上事故。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Yaml 文件中也是可以引用参数的，通过 ${name} 即可。&lt;br /&gt;我们可以通知此功能，在 K8S 中，将关键信息放到 secret 保存，通过环境变量挂在到 Pod 中，然后在 Yaml 中引用，最终能实现敏感信息单独存放 secret，控制人员的访问的权限避免泄漏，Pod Shell 的权限也需要管控。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    当使用 Cloudfront 时，源站是 ALB，可以通过 AWS-managed prefix list for CloudFront 添加到 ALB 安全组中，就能做到只有 Cloudfront 节点能访问源站了，避免了源站直接对 ALL 开放。&lt;br /&gt;如果需要指定特定的 Cloudfront，还可以通过请求头匹配的方式，在 Cloudfront 中添加回源请求头，然后 ALB 的规则中加上对应的请求头匹配。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Athena 查询速度提升，可以通过分区表来缩小查询范围，从而提升查询速度。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>20250215</title>
      <link>http://localhost:1313/2025/02/15/20250215/</link>
      <pubDate>Sat, 15 Feb 2025 02:26:51 +0000</pubDate>
      <guid>http://localhost:1313/2025/02/15/20250215/</guid>
      <description>&lt;p&gt;近几个月有点恍惚，回想一下好像没做什么，简单列一下做的内容&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    AWS CloudWatch 的告警触发，在告警不恢复的情况，默认不会再触发第二次，需要使用 Step Function 来定期检查状态，不恢复时再次通知&lt;br /&gt;&lt;a href=&#34;https://aws.amazon.com/cn/blogs/china/use-aws-step-functions-to-implement-continuous-amazon-cloudwatch-alarms/&#34;&gt;https://aws.amazon.com/cn/blogs/china/use-aws-step-functions-to-implement-continuous-amazon-cloudwatch-alarms/&lt;/a&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    告警聚合，避免告警轰炸，同时在告警方面，也要避免告警单点，或者要有对应的告警升级机制。告警升级机制也许是比较合理的，多人同时告警，可能会导致大家互相认为对方会处理&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    AWS CloudFront 迁移方案，新的 CloudFront 的域名可以用 *.example.com 替代的，它的匹配逻辑是先精确匹配，后续会模糊匹配&lt;br /&gt;&lt;a href=&#34;https://aws.amazon.com/cn/blogs/china/smoothly-migrate-alternative-domain-names-to-other-accounts/&#34;&gt;https://aws.amazon.com/cn/blogs/china/smoothly-migrate-alternative-domain-names-to-other-accounts/&lt;/a&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Gitlab CI 测试，大致了解了 Runner 的各种类型，当时一直被 Instance 类型的 Runner 迷惑，后续才发现 Instance 类型的 Runner 是在这个 Instance 上再通过 Docker Container 运行 Runner，而我的需求是把这个 EC2 变成 Runner，所以采用 ssh 类型就好了&lt;br /&gt;The instance executor is an autoscale-enabled executor that creates instances on demand to accommodate the expected volume of jobs that the runner manager processes.&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    AWS 成本根据 tag 来细分，需要在 cost 中配置对应的 tag 分账才会生效，默认是没有的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    CloudWatch exporter 测试，用来获取所有队列的监控信息，Prometheus 再抓取数据，从而可以利用 PromQL 来实现比 CloudWatch 更复杂的告警语句&lt;br /&gt;我们想实现死信队列的消息数监控，并且队列名是变化的，使用 CloudWatch 一直没找到模糊查询的 SQL 写法&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    K8S 大型集群中，需要注意 CoreDNS 的性能和指标&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    对于网关等关键入口，可以增加请求成功率的监控，这个指标能快速发现问题&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Karpenter 组件的升级，v1.0 版本大调整，升级难度增加很多，但同时也增加了对 Karpenter 的熟悉&lt;br /&gt;IAM Role 的变更比较麻烦，安装的时候和官方啊的步骤有些差异，导致升级的难度增加&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    GitOps 实践，ArgoCD 安排上了&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>大小问题记录</title>
      <link>http://localhost:1313/2024/12/25/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 25 Dec 2024 09:05:37 +0000</pubDate>
      <guid>http://localhost:1313/2024/12/25/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;记录遇到的相关问题。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;阿里云slb-5xx和4xx波动&#34;&gt;阿里云slb 5xx和4xx波动&lt;/h2&gt;&#xA;&lt;p&gt;现象：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    告警平台发生 slb 5xx 和 4xx 波动告警&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;排查过程：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    通过 slb 日志过滤，5xx 中主要是 502 占比很高，4xx 中主要是 499 的占比很高，只有一个域名出现此状况&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    通过 502 状态码初步判断是后端服务不可用，然后客户端在不断重试，导致 499 状态码的请求增多&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    根据域名和 slb 的监听定位后端服务，检查最底层后端服务，发现 nginx error log 中提示 upstream 无法连接&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    upstream 的后端是 php 的服务，查看运行状态正常，服务没有挂掉&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    判断是服务处理不过来，可能是配置的线程数可能太少，影响了服务的处理能力&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    检查配置文件，发现 pm.max_children 配置仅有 5&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    提升 pm.max_children 值到 10 倍到 50，重启 php-fpm&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    观察 nginx error log，发现错误已恢复&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;后续：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    仅配置 pm.max_children 并不是一个合理的做法，同时还需要调整 pm.start_servers, pm.min_spare_servers, pm.max_spare_server&lt;br /&gt;pm.start_servers(初始进程值) 一般是 max_children 值的 20%&lt;br /&gt;pm.min_spare_servers(至少保持空闲的进程值) 一般是 pm.start_servers 的 50%&lt;br /&gt;pm.max_spare_servers(最大保持空闲值) 一般是 pm.start_servers 的 2 倍&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    需要注意的是，pm.max_children 需要根据服务器的资源情况来决定&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;总结：&lt;/p&gt;</description>
    </item>
    <item>
      <title>对业务高可用的思考</title>
      <link>http://localhost:1313/2024/11/19/%E5%AF%B9%E4%B8%9A%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 19 Nov 2024 14:56:54 +0000</pubDate>
      <guid>http://localhost:1313/2024/11/19/%E5%AF%B9%E4%B8%9A%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;解决单点&#34;&gt;解决单点&lt;/h2&gt;&#xA;&lt;p&gt;在高可用中，应该避免单点的存在&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    业务服务多副本&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    controller 控制器多副本&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    多可用区部署&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    NAT 多公网 IP 出口&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    数据库等中间件可以采取主从模式，单点故障时可以快速切换&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    告警单点，避免告警接口人在一个人身上，导致通知失败&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;资源确保&#34;&gt;资源确保&lt;/h2&gt;&#xA;&lt;p&gt;资源的量需要有保障，避免出现资源不足的情况&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    对于 K8S 中关键性的组件，确保有足够的资源。我们可以利用 Affinity 和 Taints 机制，确保关键组件运行在单独的节点池上，避免受到其他业务的影响。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    常规业务，需要规划好 requests 和 limits，合理分配资源，配合资源监控，及时调整，避免资源浪费或者不够。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    可以利用 Karpneter 或者 Cluster Autoscaler 等组件，动态扩展节点池，确保计算资源足够&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;监控完善&#34;&gt;监控完善&lt;/h2&gt;&#xA;&lt;p&gt;利用 Prometheus 和 Grafana 监控资源利用和业务相关指标，制定高优先级告警规则，及时发现问题&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    中间件监控，CPU、内存、连接数、主从读写延时、消息堆积等等指标&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    容器资源使用监控，流量敏感型服务需要添加流量监控&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    应用监控和链路追踪，从应用内部获取到处理是否有异常并及时告警&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    异常日志监控&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    网关层监控，用量波动和大批量错误发生时应及时告警&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    云产品 Quota 监控，不够时及时申请更多的 Quota&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在告警的时候，需要有相应的重复机制，在一段时间内未恢复，需要再次提醒，同时也可以考虑告警上升机制。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;兜底机制&#34;&gt;兜底机制&lt;/h2&gt;&#xA;&lt;p&gt;在设计系统的时候，需要考虑出现问题之后如何兜底&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    重试，业务内部可以添加重试机制，例如在下载 S3 文件的时候，就可以添加重试机制&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    重连，对于中间件的连接应具备重连机制，避免中间件出现主从切换、引擎补丁安装重启之后自动重连回来&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    数据备份，开启云数据库的实时备份，可以快速恢复到备份期限内特定时间点的数据，定期检查备份的有效性&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    K8S 的就绪检查（Readiness Probe）和健康检查（Liveness Probe）配置，确保健康检查不可用时触发 K8S 的重启机制&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    入口流量快速切换。应该准备备用链路，在遇到特殊情况下，可以快速增加入口流量带宽或者切换到备用入口&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    限流机制，业务应该有相应的限流机制，避免系统被突然的大流量击垮，导致无法提供服务&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;不出问题不代表没有问题，很多时候需要系统的考虑哪里可能出问题，应该如何避免，以及出问题之后有哪些处理措施。&lt;/p&gt;&#xA;&lt;p&gt;平时也需要多加演练，在故障发生时也能更加胸有成竹。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tracepath Traceroute MTR</title>
      <link>http://localhost:1313/2024/11/07/tracepath-traceroute-mtr/</link>
      <pubDate>Thu, 07 Nov 2024 15:55:28 +0000</pubDate>
      <guid>http://localhost:1313/2024/11/07/tracepath-traceroute-mtr/</guid>
      <description>&lt;p&gt;最近工作配合排查了好几次网络问题，于是经常用到了 tracepath、traceroute 和 mtr，三个工具都是跟踪并查找网络线路的，但是又各有差异，这里简单记录一下。&lt;/p&gt;&#xA;&lt;p&gt;tracepath 利用 &lt;strong&gt;UDP&lt;/strong&gt; 协议，通过回来的数据包探测网络线路，并且在执行时不需要 root 权限，在权限不够的情况下，使用 tracepath 是一个很好的选择。&lt;/p&gt;&#xA;&lt;p&gt;traceroute 则是利用 ICMP 协议来探测网络线路，同时可以通过参数指定使用 TCP、UDP协议来探测，可以看下述例子。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;614&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-1024x614.jpg&#34; alt=&#34;&#34; class=&#34;wp-image-275&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-1024x614.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-300x180.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034-768x460.jpg 768w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992444034.jpg 1452w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;解读：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    * * * 表示没有返回数据包，这在一些商业设备中很常见，它们屏蔽了来自 traceroute 的探测&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    ip 后边的 ms 则是源到这个点的 RTT，每次 traceroute 会发送 3 个数据包来验证&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;mtr 是 My Traceroute 缩写，它是 traceroute 和 ping 的结合体，除了能看到网络经过的各个点，它还可以显示到目的地的路线中不断更新的延迟和丢包信息，可以实时看到路径上发生的情况，协助排除网络问题。&lt;figure class=&#34;wp-block-gallery has-nested-images columns-default is-cropped wp-block-gallery-5 is-layout-flex wp-block-gallery-is-layout-flex&#34;&gt; &amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a4a7dd&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-full is-style-default wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;2560&#34; height=&#34;716&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; data-id=&#34;279&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-scaled.jpg&#34; alt=&#34;&#34; class=&#34;wp-image-279&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-scaled.jpg 2560w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-300x84.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-1024x287.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-768x215.jpg 768w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-1536x430.jpg 1536w, https://glog.likungong.com/wp-content/uploads/2024/11/1730992747686-1-2048x573.jpg 2048w&#34; sizes=&#34;auto, (max-width: 2560px) 100vw, 2560px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &lt;/figure&gt; &#xA;&lt;p&gt;解读：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S中的服务使用GPU</title>
      <link>http://localhost:1313/2024/10/12/k8s%E4%B8%AD%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8gpu/</link>
      <pubDate>Sat, 12 Oct 2024 10:55:36 +0000</pubDate>
      <guid>http://localhost:1313/2024/10/12/k8s%E4%B8%AD%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8gpu/</guid>
      <description>&lt;p&gt;GPU 作为目前图形处理和 AI 任务必须的资源，这里简单记录一下在 K8S 中的程序，它们是如何使用 GPU 的。&lt;/p&gt;&#xA;&lt;p&gt;这里以 AWS EKS 进行相关记录&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li class=&#34;has-medium-font-size&#34;&gt;&#xA;    确保使用的机器是有 GPU 硬件，例如 AWS 的 g4dn，g6 等机型就是带有 GPU 硬件的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    在 EKS 中添加 GPU Node Group，注意使用的 AMI （操作系统镜像）需要带有 GPU 驱动和 cuda，选择 Amazon Linux 2023 Nvidia 的镜像&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    安装 &lt;a href=&#34;https://github.com/NVIDIA/k8s-device-plugin&#34;&gt;&lt;strong&gt;k8s-device-plugin&lt;/strong&gt;&lt;/a&gt; 组件，它会以 daemonset 的方式运行在节点上，如果我们的 GPU 节点配置了对应的污点，安装时需要修改对应的容忍机制&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    安装完 k8s-device-plugin 之后，我们通过 &lt;code&gt;kubectl describe node&lt;/code&gt;，可以在 Capacity 中可以看到可用的 GPU 数量。当我们登录 GPU 节点，执行 &lt;code&gt;nvidia-smi&lt;/code&gt; ，也可以看到 GPU 的相关信息&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;350&#34; height=&#34;125&#34; class=&#34;wp-image-255&#34; style=&#34;width: 350px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352.jpeg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352.jpeg 848w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352-300x107.jpeg 300w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181352-768x274.jpeg 768w&#34; sizes=&#34;auto, (max-width: 350px) 100vw, 350px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    使用 GPU 感知的镜像来启动 Pod，例如 &lt;code&gt;nvidia/cuda:11.0-base&lt;/code&gt;，它们内部已经包含了使用 GPU 需要的库、驱动程序、工具，使得容器内的应用程序能够有效地利用GPU资源进行计算&lt;br /&gt;在 deployment 中，我们需要在 requests 中标明需要的 GPU&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;350&#34; height=&#34;103&#34; class=&#34;wp-image-256&#34; style=&#34;width: 350px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532.jpeg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532.jpeg 786w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532-300x89.jpeg 300w, https://glog.likungong.com/wp-content/uploads/2024/10/20241012-181532-768x227.jpeg 768w&#34; sizes=&#34;auto, (max-width: 350px) 100vw, 350px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;至此，我们就可以在 k8s 的容器中调用节点的 GPU 资源了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>重新认识Kubernetes events</title>
      <link>http://localhost:1313/2024/08/27/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86kubernetes-events/</link>
      <pubDate>Tue, 27 Aug 2024 02:56:54 +0000</pubDate>
      <guid>http://localhost:1313/2024/08/27/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86kubernetes-events/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;event是什么&#34;&gt;event是什么&lt;/h2&gt;&#xA;&lt;p&gt;Kubernetes 中的组件状态发生变化，它就会产生一个事件，也就是 event 。在 event 中提供了集群的状态和健康信息，例如：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    容器创建失败&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Pod 在不停的被调度&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;事件存储在 Etcd 中，&lt;strong&gt;默认只存储最近 1 个小时&lt;/strong&gt;。如果需要持久化事件，可以通过 &lt;a href=&#34;https://github.com/resmoio/kubernetes-event-exporter&#34;&gt;kubernetes-event-exporter&lt;/a&gt; 持久化到 ElasticSearch 中。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;event的数据结构&#34;&gt;event的数据结构&lt;/h2&gt;&#xA;&lt;p&gt;平时使用比较多的查看 event 的方法&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl describe node &amp;lt;node_name&amp;gt;&#xA;&lt;p&gt;kubectl describe pod &amp;lt;pod_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;204&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1024x204.png&#34; alt=&#34;&#34; class=&#34;wp-image-226&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1024x204.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-300x60.png 300w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-768x153.png 768w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-1536x306.png 1536w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-1-2048x408.png 2048w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里显示了常用的字段，如果需要查看完整的字段，可以&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl get events -ojson&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;925&#34; height=&#34;1024&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-925x1024.png&#34; alt=&#34;&#34; class=&#34;wp-image-228&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-925x1024.png 925w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-271x300.png 271w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2-768x850.png 768w, https://glog.likungong.com/wp-content/uploads/2024/08/图片-2.png 1234w&#34; sizes=&#34;auto, (max-width: 925px) 100vw, 925px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CDN资源被盗刷记录</title>
      <link>http://localhost:1313/2024/08/20/cdn%E8%B5%84%E6%BA%90%E8%A2%AB%E7%9B%97%E5%88%B7%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 20 Aug 2024 02:17:45 +0000</pubDate>
      <guid>http://localhost:1313/2024/08/20/cdn%E8%B5%84%E6%BA%90%E8%A2%AB%E7%9B%97%E5%88%B7%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;问题&#34;&gt;问题&lt;/h2&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    带宽使用从平时的 2Gbps 提升到了 20Gbps&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    每日的 CDN 费用从 2000 上涨到了 20000&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;处理&#34;&gt;处理&lt;/h2&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    通过监控发现，现状已经持续了 5 天左右&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    查看运营报表（阿里云自带），发现有几个特定的 IP 一直在访问一个 APK 资源，并且过去 7 天下载了 1.4PB 的流量&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    在 CDN 控制台中封禁这些 IP，带宽使用下降&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    发现攻击者切换 IP ，继续访问这个 APK 资源，带宽使用上涨&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    配置此资源下载限速，一开始配置的 20MB，发现仅对单次连接生效，效果不佳，降低到最低限速 100Kb，带宽使用下降&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    攻击者还是在切换 IP 持续访问&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    确定资源是 2020 年的资源，目前已不在使用&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    从源站中重命名资源，刷新 CDN 缓存，从而清除 CDN 中的缓存&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    此时再访问资源 404，带宽使用恢复&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;思考&#34;&gt;思考&lt;/h2&gt;&#xA;&lt;p&gt;存在的问题：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    没有及时发现流量被盗刷&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    没有限速机制&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    历史资源没有生命周期管理机制，一直存在&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果攻击者更换了新的 IP 和资源，我们应该怎么办？&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    需要考虑使用其他的特征来进行封禁，例如 User-Agent、Referer 等内容&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    考虑接入 WAF ，利用 WAF 来封禁&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;应该如何防止此类事件？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    添加监控。对于按使用量计算的指标，可以添加对应的上限监控。例如：带宽、流量、费用&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    配置下载限速&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    建立资源的生命周期机制。没有资源的下线机制，冗余资源会越来越多&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;为什么被刷&#34;&gt;为什么被刷&lt;/h2&gt;&#xA;&lt;p&gt;网络上看到的解释，对比当时的场景十分符合，针对一个 url 不停的下载，去平衡 pcdn 的下载流量，避免家庭带宽上传过多被运营商封禁。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP缓存</title>
      <link>http://localhost:1313/2024/08/05/http%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 05 Aug 2024 03:30:41 +0000</pubDate>
      <guid>http://localhost:1313/2024/08/05/http%E7%BC%93%E5%AD%98/</guid>
      <description>&lt;p&gt;最近一直在搞 CDN 相关的东西，碰到最多的便是缓存了，简单记录一下相应的内容。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;缓存是什么&#34;&gt;缓存是什么&lt;/h2&gt;&#xA;&lt;p&gt;客户端浏览器访问网页时，需要从服务端拉取到相应的资源，但是有的客户端离服务端可能会很远，访问的时候会直观感受到 &lt;strong&gt;慢&lt;/strong&gt;，缓存就是用来解决这一问题的。&lt;/p&gt;&#xA;&lt;p&gt;缓存有哪些：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    本地缓存。浏览器会根据请求头的策略，将数据缓存在内存或者磁盘中&lt;br /&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;550&#34; height=&#34;208&#34; class=&#34;wp-image-197&#34; style=&#34;width: 550px;&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33.jpg&#34; alt=&#34;&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33.jpg 1482w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-300x114.jpg 300w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-1024x388.jpg 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/Snipaste_2024-07-29_22-40-33-768x291.jpg 768w&#34; sizes=&#34;auto, (max-width: 550px) 100vw, 550px&#34; /&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    CDN。Content Delivery Network，将资源先存放在离用户近的地方，这样用户访问的链路更短，访问的时候便可以加速，同时 CDN 访问服务端源站也会有相应的加成（CDN提供商的网络比客户本地的网络会更可靠）&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何控制缓存&#34;&gt;如何控制缓存&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;浏览器如何确定我能否缓存这个资源呢?&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;它是通过 http Response 中的 &lt;strong&gt;Cache-Control&lt;/strong&gt; 请求头来决定的。&lt;/p&gt;&#xA;&lt;p&gt;缓存行为：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    public ：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    private ：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    no-cache ：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    no-store ：不使用任何缓存&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存时间：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    max-age=&lt;seconds&gt; &lt;br /&gt;设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)，时间是相对于请求的时间。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;目前接触比较多的参数主要是上述这些，更多的参数可以参照 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control&#34;&gt;MDN文档&lt;/a&gt;。除了&lt;br&gt;&#xA;Cache-Control 头之外，http 中还会通过 Etag 请求头作为资源的唯一标签。&lt;/p&gt;&#xA;&lt;p&gt;在缓存到期之后，再请求资源，客户端会通过 If-None-Match 带上 Etag 的内容，发送给服务端，服务端判断资源是否发生变化，未发生变化，则返回 304 Not Modified，这样就无需再传输完整的资源，节省了带宽。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;浏览器如何判断缓存过期了呢？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;服务端响应的头中，除了 Cache-Control ，还有一个 Date 的头，记录请求的时间，这样便可以根据 Date + max-age 的秒数，拿到缓存的到期时间，再次请求资源时，缓存有效则直接使用缓存的资源。&lt;/p&gt;</description>
    </item>
    <item>
      <title>跨域</title>
      <link>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 18 Jul 2024 10:43:31 +0000</pubDate>
      <guid>http://localhost:1313/2024/07/18/%E8%B7%A8%E5%9F%9F/</guid>
      <description>&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;跨域是什么&#34;&gt;跨域是什么&lt;/h2&gt;&#xA;&lt;p&gt;跨域只发生在浏览器的访问中，发生跨域时，通常会看到 CORS error 等字眼，并且请求返回了 403 状态码。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;57&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png&#34; alt=&#34;&#34; class=&#34;wp-image-179&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/07/image-2-1024x57.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-300x17.png 300w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2-768x43.png 768w, https://glog.likungong.com/wp-content/uploads/2024/07/image-2.png 1080w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &lt;/figure&gt;&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;为什么会跨域&#34;&gt;为什么会跨域&lt;/h2&gt;&#xA;&lt;p&gt;在理解跨域之前，要先知道浏览器中的同源策略。&lt;/p&gt;&#xA;&lt;p&gt;同源策略：是指两个页面具有相同的协议、地址、端口，那么它们就是同源，只要有一个不同，就不是同源。不同源之间的访问，就会产生跨域。&lt;/p&gt;&#xA;&lt;p&gt;例如 &lt;a href=&#34;https://a.com&#34;&gt;https://a.com&lt;/a&gt; 页面里边的 JavaScript 脚本去访问 &lt;a href=&#34;https://b.com&#34;&gt;https://b.com&lt;/a&gt; ，就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;p&gt;同源策略的目的是为了保护用户隐私和数据安全，但是我们还是有需要进行合法的跨域访问的。比如我们的图片资源都是存在一个独立的 CDN 资源中，其他业务都统一来这个域名访问资源，这之间就会产生跨域的情况。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何解决跨域&#34;&gt;如何解决跨域&lt;/h2&gt;&#xA;&lt;p&gt;目前最常见解决跨域的办法，就是通过 CORS(跨域资源共享)。&lt;/p&gt;&#xA;&lt;p&gt;CORS(跨域资源共享)：通过设置HTTP头来允许跨域请求。&lt;/p&gt;&#xA;&lt;p&gt;在上述的例子中，a.com 如何知道自己能够跨域访问 b.com 呢？它会在发起 GET、POST 等这些请求前，先发起一个 preflight 的请求，也就是 OPTIONS 请求，根据返回判断 b.com 是否允许自己访问。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的一点是，并不是所有的跨域都会发起 preflight 请求，同时满足以下情况是不会发起 OPTIONS 请求的：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    请求方法是 GET、POST、HEAD&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    请求中没有特殊的请求头&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;跨域主要涉及的请求头信息：&lt;/p&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Origin&amp;nbsp;用于设置允许跨域请求源地址 （预检请求和正式请求在跨域时候都会验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Headers&amp;nbsp;跨域允许携带的特殊头信息字段 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Methods&amp;nbsp;跨域允许的请求方法或者说HTTP动词 （只在预检请求验证）&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Access-Control-Allow-Credentials&amp;nbsp;是否允许跨域使用cookies，如果要跨域使用cookies，可以添加上此请求响应头，值设为true（设置或者不设置，都不会影响请求发送，只会影响在跨域时候是否要携带cookies，但是如果设置，预检请求和正式请求都需要设置）&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安全起见，Access-Control-Allow-Origin 一般不会设置 * 对所有开放，而是指定域名开放&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;nginx中解决跨域&#34;&gt;Nginx中解决跨域&lt;/h3&gt;&#xA;&lt;p&gt;在 Nginx 的配置中，需要处理 OPTIONS 请求，同时对于 OPTIONS 之后的请求也需要添加对应的响应头&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S ServiceAccount</title>
      <link>http://localhost:1313/2024/05/31/k8s-serviceaccount/</link>
      <pubDate>Fri, 31 May 2024 15:39:46 +0000</pubDate>
      <guid>http://localhost:1313/2024/05/31/k8s-serviceaccount/</guid>
      <description>&lt;p&gt;近期又频繁接触 K8S，发现以前自己学的很多都已经发生变化，觉得有必要记录一下。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;serviceaccount是什么&#34;&gt;ServiceAccount是什么&lt;/h2&gt;&#xA;&lt;p&gt;服务账号，顾名思义是用来做身份标识的，它与平时接触的账号又有一些不一样。在 K8S 中，Pod、系统组件以及集群外的实体都可以使用 &lt;strong&gt;ServiceAccount 凭证&lt;/strong&gt; 标识自己为对应的 ServiceAccount，以此来获取访问 K8S 其他资源的权限。&lt;/p&gt;&#xA;&lt;p&gt;可以通过以下命令查看 ServiceAccount&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl get sa -n default&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;serviceaccount使用场景&#34;&gt;ServiceAccount使用场景&lt;/h2&gt;&#xA;&lt;p&gt;目前接触到的使用场景有这些：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    利用 ServiceAccount 的 secret，生成一个 kubeconfig 作为 CD 流水线中操作 K8S 的凭证&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    在 Pod 中利用 ServiceAccount 和 K8S 自身通信，调用 API 启动 JOB 类型的 Pod，或者拿到 configmap 中的配置&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    将 AWS 的 role 绑定到对应的 ServiceAccount，使 Pod 拥有对应 role 的权限，比如直接访问 S3 的权限&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;使用serviceaccount-token生成kubeconfig&#34;&gt;使用ServiceAccount token生成kubeconfig&lt;/h3&gt;&#xA;&lt;p&gt;通过以下方法创建一个长期有效的 Token（&lt;strong&gt;长期有效的 token 可能造成安全问题&lt;/strong&gt;，谨慎使用），主要是&lt;br&gt;&#xA;&lt;code&gt;type: kubernetes.io/service-account-token&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF&#xA;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: sa-secret&#xA;  annotations:&#xA;    kubernetes.io/service-account.name: sa&#xA;type: kubernetes.io/service-account-token&#xA;EOF&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;查看 token&lt;/p&gt;</description>
    </item>
    <item>
      <title>对CI、CD的理解记录</title>
      <link>http://localhost:1313/2024/05/14/%E5%AF%B9ci%E3%80%81cd%E7%9A%84%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 14 May 2024 14:37:35 +0000</pubDate>
      <guid>http://localhost:1313/2024/05/14/%E5%AF%B9ci%E3%80%81cd%E7%9A%84%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;近期又接触了阿里云 flow 这个工具，发现自己对 CI、CD 这块一直没有比较成型的记忆，所以简单整理记录一下。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;ci-cd是什么&#34;&gt;CI CD是什么&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;&#xA;  &lt;p&gt;&#xA;  &lt;/p&gt;&#xA;&lt;p&gt;&lt;cite&gt;CI：持续集成，开发人员在每次更改代码后都会将代码提交到版本控制系统。然后，CI 服务器会自动构建、测试和验证代码。&lt;br /&gt;&lt;br /&gt;CD：持续交付/部署，持续部署到服务器中。&lt;/cite&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;CI、CD 的整个过程都是围绕着自动化产生的，力求做到更快、更可靠的交付。&lt;/p&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;制品&#34;&gt;制品&lt;/h2&gt;&#xA;&lt;p&gt;制品可以理解是 CI 的产物，它可以是一个 Jar 包、一个 Docker 镜像、一个二进制文件。&lt;/p&gt;&#xA;&lt;p&gt;制品是连接 CI 、CD 的传动轴。&lt;/p&gt;&#xA;&lt;p&gt;制品不应该是死的，应该给它赋予 &lt;strong&gt;元数据&lt;/strong&gt;，这些元数据可以标识制品是否被测试过、是否符合上线的标准，从而定义好 &lt;strong&gt;制品的生命周期&lt;/strong&gt;。Jfrog Artifactory 很好的体现了这一点，而 Nexus 只是单纯的存储仓库，想要做到元数据，还需要额外的系统进行配合。&lt;/p&gt;&#xA;&lt;p&gt;制品生命周期：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    开发阶段，对应 dev 仓库，保留最近15天的数据&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    测试阶段，对应 test 仓库，保留最近15天的数据&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    预发布阶段，对应 stage 仓库，制品永久保留&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    正式发布，对应 release 仓库，制品应该是从 stage 仓库 Promete 提升上来的，也需要永久保留&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;如何设计ci-cd流水线&#34;&gt;如何设计CI CD流水线&lt;/h2&gt;&#xA;&lt;p&gt;目前主要接触过 2 种设计：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    CI、CD 所有功能都集中在一条 pipeline 中。这种方法适用于 pipeline 不复杂的情况，能够一步到位，完成所有事情。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    CI、CD 分两条不同的 pipeline，各自负责相应的事情。通过制品使 CI、CD 关联起来，分开的 CI、CD 相对更加灵活，权限管控更加方便。&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;串行和并行：例如代码扫描和编译和并行执行，提升效率&lt;/p&gt;</description>
    </item>
    <item>
      <title>dig &#43;trace 输出解读</title>
      <link>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 27 Apr 2024 04:18:43 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/27/dig-trace-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB/</guid>
      <description>&lt;p&gt;这几天遇到了一个 DNS 问题，然后在使用 dig 的过程中，很多字段自己只是一知半解，有点模糊，特意抽时间了解了这方面的内容，顺便记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dns递归解析过程&#34;&gt;DNS递归解析过程&lt;/h3&gt;&#xA;&lt;p&gt;DNS 服务器分类：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    递归 DNS 解析器&lt;br /&gt;类似运营商下发的 DNS 服务器或者像阿里云、腾讯云 dnspod 这种，都是递归 DNS 解析器，其中像阿里云、腾讯云这种对公共开放的 DNS，也称 &lt;strong&gt;公共 DNS&lt;/strong&gt;&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    根域名服务器&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    TLD 名称服务器&lt;br /&gt;顶级域名服务器，类似 &lt;strong&gt;.com&lt;/strong&gt; ，&lt;strong&gt;.org &lt;/strong&gt;这种&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    权威性域名服务器&lt;br /&gt;类似 &lt;strong&gt;ns-115.awsdns-14.com.&lt;/strong&gt; ，会给你返回最终的解析结果给到递归 DNS 解析器，递归 DNS 解析器再返回给客户端&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;递归 DNS 的解析过程，引用 cloudflare 的示意图，更详细的过程参考 &lt;a href=&#34;https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/&#34;&gt;cloudflare文档&lt;/a&gt;&lt;figure class=&#34;wp-block-gallery has-nested-images columns-default is-cropped wp-block-gallery-1 is-layout-flex wp-block-gallery-is-layout-flex&#34;&gt; &amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a41e11&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-large wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;512&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; data-id=&#34;123&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png&#34; alt=&#34;&#34; class=&#34;wp-image-123&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1024x512.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-300x150.png 300w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-768x384.png 768w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-1536x768.png 1536w, https://glog.likungong.com/wp-content/uploads/2024/04/what_is_a_dns_server_dns_lookup-2048x1024.png 2048w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &lt;/figure&gt; &#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;dig-trace&#34;&gt;dig +trace&lt;/h3&gt;&#xA;&lt;p&gt;dig 使用 &lt;code&gt;+trace&lt;/code&gt; 之后，会从根域名服务器开始，一步一步 trace 整个域名的解析过程&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何指定docker compose中容器的网段</title>
      <link>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</link>
      <pubDate>Fri, 19 Apr 2024 01:56:19 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/19/%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9Adocker-compose%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E6%AE%B5/</guid>
      <description>&lt;p&gt;Docker 安装后，看到 &lt;code&gt;docker0&lt;/code&gt; 网卡使用的是 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段，后续 &lt;code&gt;Docker Run&lt;/code&gt; 运行起来不指定网络的容器，拿到的网络地址都是属于这个网段。&lt;/p&gt;&#xA;&lt;p&gt;但是对于利用 Docker Compose 启动得到的容器，它们的 IP 地址并不是从 &lt;code&gt;172.17.0.1/16&lt;/code&gt; 网段获取的，而是重新创建了一个虚拟网卡，分配了一个新的网给它的容器的使用。&lt;/p&gt;&#xA;&lt;p&gt;默认 Docker Compose 会从 &lt;code&gt;172.16.0.0/12&lt;/code&gt; 网络的地址范围 （&lt;code&gt;172.16.0.0/16&lt;/code&gt; ~ &lt;code&gt;172.31.255.255/16）&lt;/code&gt; 中挑选一个不重复的进行使用。但是有的时候 Docker Compose 挑选到的网络会和我们网络内其他网段冲突，就会导致容器和那个网络段的服务访问会有问题（路由会有问题），这个时候我们就要手动指定网段，解决网络冲突。&lt;/p&gt;&#xA;&lt;p&gt;配置如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-json&#34; data-lang=&#34;JSON&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;&lt;p&gt;services:&#xA;frontend:&#xA;image: frontend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;backend:&#xA;image: backend-app&#xA;networks:&#xA;- custom-network&lt;/p&gt;&#xA;&lt;p&gt;networks:&#xA;custom-network:&#xA;driver: bridge&#xA;ipam:&#xA;config:&#xA;- subnet: 192.168.250.0/24&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>对自己职业的思考</title>
      <link>http://localhost:1313/2024/04/14/%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%81%8C%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 14 Apr 2024 04:16:39 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/14/%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%81%8C%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;近期，离开做了 3 年的公司，去了新公司，引起了我对自己整个职业过程的一些思考。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;过去的总结&#34;&gt;过去的总结&lt;/h3&gt;&#xA;&lt;p&gt;回想过去，主要可以分为以下阶段：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    入门阶段。刚毕业踏入的一个公司，是我踏入 Linux 世界的引导者，当时办公都是用 Ubuntu ，也为后来做运维工作打下基础。&lt;br /&gt;总体来说，当时时间很多，自己却没有方向，也没有寻求别人的意见，欠缺主动学习，也许当时稍微改变，后续的路线也会发生翻天覆地的变化。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    进步阶段。来到深圳入职新公司，无比饥渴的学习各种各样的知识，K8S、持续集成部署。&lt;br /&gt;总体来说，接触了很多新东西，也算是走上了运维这条路，但是部门只有我一个运维，领导也给不了太多建议，自己也没有从外界获取相应的内容，逐渐迷茫至离职。回想起来，很多事情其实能做到更好，也能得到更多的进步，而自己却没有做到。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    停滞阶段。跳槽下一家做 DevOps，吃老本，Azure DevOps。&lt;br /&gt;总体来说，吃老本，没有什么新突破，换汤不换药，到最后出走，最大的幸运是找到了未来老婆。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    云运维阶段。再来到下一家，进入云服务运维阶段，阿里云、AWS、IOT，同时也涉及到了一些运维开发工作。&lt;br /&gt;总体来说，个人成熟很多，也接触了更多新东西，技能的面也有了扩展，但还是缺乏独当一面的能力。&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;回顾整个工作进程，总感觉自己有很多地方做的不够好&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    积累太少。很多都是一点一点积累起来的，而自己有时执着于工具，而忽略了内容的重要性，经常放弃过去积累的东西，而不是去修补，去完善，导致进步缓慢。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    思考太少。体现在对问题、对当下、对未来的思考太少，喜欢逃避。很多事情其实能做到更好，总是后知后觉。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    交流太少。同行交流太少，也容易对网上的观点嗤之以鼻，不以为意，不深入思考。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    不够系统。一件事情只知其，不知其所以然。通过搜索解决了问题，后续却没有做整体学习，导致学到的知识生硬。&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;未来的想法&#34;&gt;未来的想法&lt;/h3&gt;&#xA;&lt;p&gt;在新公司整理了当前的业务情况，个人有点悲哀，业务的云化程度很高，在我看来很多事情其实开发在简单理解之后也能胜任，我需要考虑我能为团队带来什么。&lt;/p&gt;&#xA;&lt;p&gt;云服务时代，降低了纯业务运维的重要性，使得开发可以兼当运维，在不算很大的场景下，这种方式能降低人员成本。&lt;/p&gt;&#xA;&lt;p&gt;对当前工作是有一点悲观，也许发展前景不算太好，但总要养家糊口，还需要自己找到突破口。&lt;/p&gt;&#xA;&lt;p&gt;大的方面：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    &lt;strong&gt;学习方法调整&lt;/strong&gt;。凡事讲究一个 What-How-Why，多积累，定期回顾。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    &lt;strong&gt;慢下来，也许会更快&lt;/strong&gt;。一开始不要太过追求知识的全面性，有的时候更多是自己觉得掌握了，但一到实操却发现啥也不会，这时不如先掌握一个知识点，再以点破面。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    &lt;strong&gt;自信&lt;/strong&gt;。不够自信，有的时候太在乎别人的看法。&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;工作内容思考：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    成本。云服务时代，成本的重视程度要提高。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    可观测。服务的可观测性，在微服务时代，服务的数量很多，提高可观测性，在问题发生时可以提供有效的排查数据。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    开发能力(自动化)。开发不是只局限于业务系统，并不是写业务才算开发，更多的时候要考虑用机器帮你完成事情，而不是自己手动完成。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    AI 能力。接轨 AI 时代，利用 AI 来提升自己的能力。&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>SNI</title>
      <link>http://localhost:1313/2024/04/02/sni/</link>
      <pubDate>Tue, 02 Apr 2024 02:56:32 +0000</pubDate>
      <guid>http://localhost:1313/2024/04/02/sni/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;sni是什么&#34;&gt;SNI是什么&lt;/h3&gt;&#xA;&lt;p&gt;SNI: Server Name Indication 服务名称标识。顾名思义，是用来标识服务名的&lt;/p&gt;&#xA;&lt;p&gt;服务名：一般表示的是网站域名&lt;/p&gt;&#xA;&lt;p&gt;在现如今的 Web 服务器，一般同个 IP + 端口 会包含多个网站，在 https 协议中，每个域名可能都会有自己的证书，如果只有 IP 地址，在访问 https 的时候，服务端不足以判断访问哪个域名，从而可能导致 &lt;strong&gt;SSL证书错误&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;SNI 就是用来标识访问的域名是哪个，起到一个引路的作用。&lt;/p&gt;&#xA;&lt;p&gt;SNI 主要用在 https 中，在 http 中是没有 SNI 的，因为 http 没有 tls 握手的过程，直接通过请求头中的 Host 字段判断访问的哪个域名。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;sni的体现&#34;&gt;SNI的体现&lt;/h3&gt;&#xA;&lt;p&gt;SNI 主要在 TLS 握手的 client hello 的扩展信息中，以此发给服务端&amp;lt;figure data-wp-context=&amp;quot;{&amp;ldquo;imageId&amp;rdquo;:&amp;ldquo;686e6d3a3f7fb&amp;rdquo;}&amp;quot; data-wp-interactive=&amp;ldquo;core/image&amp;rdquo; class=&amp;ldquo;wp-block-image size-large wp-lightbox-container&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;604&#34; data-wp-class--hide=&#34;state.isContentHidden&#34; data-wp-class--show=&#34;state.isContentVisible&#34; data-wp-init=&#34;callbacks.setButtonStyles&#34; data-wp-on-async--click=&#34;actions.showLightbox&#34; data-wp-on-async--load=&#34;callbacks.setButtonStyles&#34; data-wp-on-async-window--resize=&#34;callbacks.setButtonStyles&#34; src=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/image-1024x604.png&#34; alt=&#34;&#34; class=&#34;wp-image-93&#34; srcset=&#34;https://glog.likungong.com/wp-content/uploads/2024/04/image-1024x604.png 1024w, https://glog.likungong.com/wp-content/uploads/2024/04/image-300x177.png 300w, https://glog.likungong.com/wp-content/uploads/2024/04/image-768x453.png 768w, https://glog.likungong.com/wp-content/uploads/2024/04/image.png 1230w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt; &#xA;&#x9;&#x9;&#x9;&lt;button&#xA;&#x9;&#x9;&#x9;class=&#34;lightbox-trigger&#34;&#xA;&#x9;&#x9;&#x9;type=&#34;button&#34;&#xA;&#x9;&#x9;&#x9;aria-haspopup=&#34;dialog&#34;&#xA;&#x9;&#x9;&#x9;aria-label=&#34;放大&#34;&#xA;&#x9;&#x9;&#x9;data-wp-init=&#34;callbacks.initTriggerButton&#34;&#xA;&#x9;&#x9;&#x9;data-wp-on-async--click=&#34;actions.showLightbox&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--right=&#34;state.imageButtonRight&#34;&#xA;&#x9;&#x9;&#x9;data-wp-style--top=&#34;state.imageButtonTop&#34;&#xA;&#x9;&#x9;&gt; &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; width=&#34;12&#34; height=&#34;12&#34; fill=&#34;none&#34; viewBox=&#34;0 0 12 12&#34;&gt; &lt;path fill=&#34;#fff&#34; d=&#34;M2 0a2 2 0 0 0-2 2v2h1.5V2a.5.5 0 0 1 .5-.5h2V0H2Zm2 10.5H2a.5.5 0 0 1-.5-.5V8H0v2a2 2 0 0 0 2 2h2v-1.5ZM8 12v-1.5h2a.5.5 0 0 0 .5-.5V8H12v2a2 2 0 0 1-2 2H8Zm2-12a2 2 0 0 1 2 2v2h-1.5V2a.5.5 0 0 0-.5-.5H8V0h2Z&#34; /&gt; &lt;/svg&gt; &lt;/button&gt;&lt;/figure&gt; &#xA;&lt;p&gt;在 Nginx 中配置多 https 的例子：&lt;/p&gt;</description>
    </item>
    <item>
      <title>利用SSH Tunnel内网穿透</title>
      <link>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Thu, 28 Mar 2024 06:14:37 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/28/%E5%88%A9%E7%94%A8ssh-tunnel%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>&lt;p&gt;SSH 除了平时连接远程服务器外，还有不少其他的功能，刚好最近有这个需求，利用了 SSH Tunnel 实现内网穿透，这里简单记录一下。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;前提&#34;&gt;前提&lt;/h3&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    需要访问的内网服务器 A&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    有公网地址外网服务器 B&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;利用公网服务器 B 来暴露服务器 A 中的端口，需要 A 主动通过 SSH 连接服务器 B&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;配置过程&#34;&gt;配置过程&lt;/h3&gt;&#xA;&lt;p&gt;SSH 原生支持远程端口转发，在内网服务器 A 上执行以下命令：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 内网服务器 A 上执行&#xA;# ssh -fN -R 23456:127.0.0.1:22 -i xxx.key B_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;命令解释：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    23456 端口，是监听在公网服务器 B 上的&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    127.0.0.1:22 表示将内网服务器 A 的 ssh 端口映射到公网服务器 23456 端口&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -f 表示后台运行&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    -N 不执行远程命令。端口转发时使用&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个时候在第三台服务器 C 上，就可以通过公网服务器 B 的公网地址 + 23456 端口，访问到内网服务器 A 了&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 三方服务器 C 上执行&#xA;$ ssh -p 23456 A_user@B_public_ip&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;进一步优化&#34;&gt;进一步优化&lt;/h3&gt;&#xA;&lt;p&gt;SSH 的连接有时会因为网络不稳定而断开，我们可以使用 &lt;a href=&#34;https://github.com/Autossh/autossh&#34;&gt;autossh&lt;/a&gt; 这个工具来帮我们维持 SSH 连接，在断开时自动重连。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何只更新Docker Compose中某个容器的版本</title>
      <link>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sat, 23 Mar 2024 15:44:45 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/23/%E5%A6%82%E4%BD%95%E5%8F%AA%E6%9B%B4%E6%96%B0docker-compose%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;p&gt;遇到了很多次这个场景，发布版本的时候，只需要更新 Docker Compose 中某个容器的镜像版本并重启，不需要重启其他依赖的容器。&lt;/p&gt;&#xA;&lt;p&gt;其实 Docker 已经为我们考虑到了这个问题了，并提供了相应的参数。&lt;/p&gt;&#xA;&lt;p&gt;方法一：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    更新 &lt;code&gt;docker-compose.yml &lt;/code&gt;中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    重新执行 &lt;code&gt;docker compose up -d &lt;/code&gt;，会自动判断那个 service 发生了变化，并重启变化的容器&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;方法二：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    同样是更新 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中的镜像 ID&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    执行 up 时，加上 &lt;code&gt;--no-deps&lt;/code&gt; 的参数，也能做到不重启其他依赖容器。这种做法的好处是可以明确指定那个容器，如果有多个容器需要重启，能做到有顺序的重启&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker compose up -d --no-deps container_name&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>K8S Pod QoS</title>
      <link>http://localhost:1313/2024/03/20/k8s-pod-qos/</link>
      <pubDate>Wed, 20 Mar 2024 14:51:00 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/20/k8s-pod-qos/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;pod-qos是什么&#34;&gt;Pod QoS是什么&lt;/h3&gt;&#xA;&lt;p&gt;QoS：Quality of Service，服务质量的意思。K8S Pod QoS 主要是对 Pod 的资源进行管理和限制的一种机制。&lt;/p&gt;&#xA;&lt;p&gt;QoS类型：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    Guaranteed：最高优先级&lt;br /&gt;Pod 中每个容器的内存和 CPU 的 request 和 limit 是一致的，不同容器的配置值是可以不相等&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    Burstable：可以短期使用更多的资源&lt;br /&gt;&amp;#8211; 设置了内存和 CPU 的 request，但是没有配置 limit&lt;br /&gt;&amp;#8211; 或者设置了 request 和 limit，但是两者不相等&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    BestEffort：最低优先级&lt;br /&gt;没有设置任何 request 和 limit&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果 Pod 中只配置了 limit，没有配置 request，那么 K8S 会复制 limit 的值提供给 requests 。&lt;/p&gt;&#xA;&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;&#xA;  &lt;p&gt;&#xA;    Note:&#xA;  &lt;/p&gt;&#xA;&lt;p&gt;&lt;cite&gt;If you specify a limit for a resource, but do not specify any request, and no admission-time mechanism has applied a default request for that resource, then Kubernetes copies the limit you specified and uses it as the requested value for the resource.&lt;/cite&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S CPU Throttling</title>
      <link>http://localhost:1313/2024/03/10/k8s-cpu-throttling/</link>
      <pubDate>Sun, 10 Mar 2024 03:26:38 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/10/k8s-cpu-throttling/</guid>
      <description>&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;什么是cpu-throttling&#34;&gt;什么是CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;在 K8S 中，内存有很明确的大小指标来衡量，一旦超过设定的 Limit，就会发生 OOM ，被系统 Kill 掉，这就是 PodOOM 事件。&lt;br&gt;&#xA;而 CPU 的衡量指标则有点模糊，是根据占据 CPU 的使用时间来决定的。CPU 使用超限了 Pod 也不会被杀掉，而是 CPU 使用会被限流。&lt;/p&gt;&#xA;&lt;p&gt;CPU Throttling 直译来说就是 CPU 使用被节流了，被限制了 CPU 的使用时间。&lt;/p&gt;&#xA;&lt;p&gt;在 K8S 中，通过调整容器中进程的 CPU 优先级(nice值，值越小，优先级越高)来达到限流的效果。&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;cpu-throttling影响什么&#34;&gt;CPU Throttling影响什么&lt;/h3&gt;&#xA;&lt;p&gt;影响：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    CPU 处理变慢了，导致服务性能下降，response_time 响应时间增加&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;如何监控cpu-throttling&#34;&gt;如何监控CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;cadvisor 提供了相应指标：&lt;/p&gt;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    container_cpu_cfs_throttled_periods_total&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    container_cpu_cfs_periods_total&#xA;  &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;一个 PromQL例子&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-sql&#34; data-lang=&#34;SQL&#34;&gt;&lt;code&gt;sum(increase(container_cpu_cfs_throttled_periods_total{container!=&#34;filebeat&#34;,cluster!~&#34;kube.*-(dev|test|pre|t|t2|t3|s|u|d)$&#34;}[5m])) by (container, pod, namespace, cluster)&#xA;  /&#xA;sum(increase(container_cpu_cfs_periods_total{cluster!~&#34;kube.*-(dev|test|pre|t|t2|t3|s|u|d)$&#34;}[5m])) by (container, pod, namespace, cluster)&#xA;  &amp;gt; ( 10 / 100 )&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;如何解决cpu-throttling&#34;&gt;如何解决CPU Throttling&lt;/h3&gt;&#xA;&lt;p&gt;解决：&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何配置Docker使用代理拉镜像</title>
      <link>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 06 Mar 2024 11:33:32 +0000</pubDate>
      <guid>http://localhost:1313/2024/03/06/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%8B%89%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;编辑 &lt;code&gt;&amp;lt;mark style=&amp;quot;background-color:#d9d9d6&amp;quot; class=&amp;quot;has-inline-color&amp;quot;&amp;gt;/etc/systemd/system/docker.service.d/http-proxy.conf&amp;lt;/mark&amp;gt;&lt;/code&gt; ，目录和文件没有就新建一下，然后配置代理内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;[Service]&#xA;Environment=&#34;HTTP_PROXY=http://xxx.com:80&#34;&#xA;Environment=&#34;HTTPS_PROXY=https://xxx.com:443&#34;&#xA;Environment=&#34;NO_PROXY=xxx-registry.com,*.example.com&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;重启 Docker&lt;/p&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;# 重启Docker&#xA;sudo systemctl daemon-reload&#xA;sudo systemctl restart docker&#xA;&lt;h1 id=&#34;检查是否正确配置&#34;&gt;检查是否正确配置&lt;/h1&gt;&#xA;&lt;p&gt;sudo systemctl show &amp;ndash;property=Environment docker&lt;/p&gt;&#xA;&lt;h1 id=&#34;确认结果&#34;&gt;确认结果&lt;/h1&gt;&#xA;&lt;p&gt;sudo docker info&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Docker compose中expose和port的区别</title>
      <link>http://localhost:1313/2024/02/21/docker-compose-expose%E5%92%8Cport%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 21 Feb 2024 15:48:19 +0000</pubDate>
      <guid>http://localhost:1313/2024/02/21/docker-compose-expose%E5%92%8Cport%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;  &lt;li&gt;&#xA;    expose 指定的端口，是提供给 compose 中其他 service 用的，不会映射到宿主机上。&#xA;  &lt;/li&gt;&#xA;  &lt;li&gt;&#xA;    port 指定的端口，则会映射到宿主机上。&#xA;  &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;expose&#34;&gt;expose&lt;/h4&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;services:&#xA;  myapp1:&#xA;    .&#xA;    expose:&#xA;      - &#34;3000&#34;&#xA;      - &#34;8000&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;port&#34;&gt;port&lt;/h4&gt;&#xA;&lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;  &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;services:&#xA;  myapp1:&#xA;    ...&#xA;    ports:&#xA;    - &#34;3000&#34;                 # 容器中的3000端口映射到主机一个随机端口&#xA;    - &#34;3001-3005&#34;            # 容器中的3001-3005端口映射到主机一个随机端口段&#xA;    - &#34;8000:8000&#34;            # 容器中的8000端口映射到主机的8000端口&#xA;    - &#34;9090-9091:8080-8081&#34;  # 容器中的8080-8081映射到主机的9090-9091&#xA;    - &#34;127.0.0.1:8002:8002&#34;  # 容器中的8002端口映射主机127.0.0.1地址的8002&#xA;    - &#34;6060:6060/udp&#34;        # 限制容器中6060端口的udp协议到主机的6060端口  &lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>如何在容器中添加hosts记录</title>
      <link>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 19 Feb 2024 16:07:56 +0000</pubDate>
      <guid>http://localhost:1313/2024/02/20/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0hosts%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;有时候需要在容器中配置指定 hosts ，这里记录一下各个场景的配置方式&lt;/p&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-run&#34;&gt;Docker run&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;code&gt;docker run --add-host=xxx.example.com:10.0.0.8 --name debian -it debian&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;docker-compose&#34;&gt;Docker compose&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;services:&#xA;  web:&#xA;    image: nginx&#xA;    extra_hosts:&#xA;      - &#34;docker:10.0.0.10&#34;&#xA;      - &#34;another-host:10.0.0.11&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;&#xA;&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-28f84493 wp-block-columns-is-layout-flex&#34;&gt;&#xA;  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;&#xA;    &lt;div class=&#34;hcb_wrap&#34;&gt;&#xA;      &lt;pre class=&#34;prism line-numbers lang-js&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Pod&#xA;metadata:&#xA;  name: hostaliases-pod&#xA;spec:&#xA;  restartPolicy: Never&#xA;  hostAliases:&#xA;  - ip: &#34;127.0.0.1&#34;&#xA;    hostnames:&#xA;    - &#34;foo.local&#34;&#xA;    - &#34;bar.local&#34;&#xA;  - ip: &#34;10.1.2.3&#34;&#xA;    hostnames:&#xA;    - &#34;foo.remote&#34;&#xA;    - &#34;bar.remote&#34;&#xA;  containers:&#xA;  - name: cat-hosts&#xA;    image: busybox:1.28&#xA;    command:&#xA;    - cat&#xA;    args:&#xA;    - &#34;/etc/hosts&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
